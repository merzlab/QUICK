#!/bin/sh

#  !---------------------------------------------------------------------!
#  ! Written by Madu Manathunga on 07/09/2020                            !
#  !                                                                     !
#  ! Copyright (C) 2020-2021 Merz lab                                    !
#  ! Copyright (C) 2020-2021 GÃ¶tz lab                                    !
#  !                                                                     !
#  ! This Source Code Form is subject to the terms of the Mozilla Public !
#  ! License, v. 2.0. If a copy of the MPL was not distributed with this !
#  ! file, You can obtain one at http://mozilla.org/MPL/2.0/.            !
#  !_____________________________________________________________________!
#
#  !---------------------------------------------------------------------!
#  ! This source code sets up the environment for QUICK compilation and  !
#  ! writes input file for make.                                         !
#  !---------------------------------------------------------------------!

#  !---------------------------------------------------------------------!
#  ! Set version                                                         !
#  !---------------------------------------------------------------------!
QUICK_VERSION='QUICK-25.03'
QUICK_HOME=`pwd`
cdate=`date +'%m/%d/%Y'`
ctime=`date +'%r'`

echo ""
echo  "Configuring $QUICK_VERSION installation started on $cdate at $ctime.."

#  !---------------------------------------------------------------------!
#  ! function definitions                                                !
#  !---------------------------------------------------------------------!

# this function prints help page
print_help(){

echo  "                                                                                                                                       
  Use this script as ./configure [flags] compiler                           
                                                                            
  Available flags are:                                                      
      --prefix <dir> User specified installation directory                  
      --serial       Builds a serial version                                
      --mpi          Compiles MPI parallel version                           
      --cuda         Builds GPU version that utilizes a single NVIDIA GPU   
      --cudampi      Builds multi-GPU version that utilizes multiple NVIDIA GPUs  
      --hip          Builds GPU version that utilizes a single AMD GPU
      --hipmpi       Builds multi-GPU version that utilizes multiple AMD GPUs
      --debug        Compiles debug version                                 
      --debug-time   Compiles a debug version that reports more information
                     on timing
      --profile      Compiles profiling version                                 
      --shared       Build shared object libraries                          
      --arch <kepler|maxwell|pascal|volta|turing|ampere|adalovelace|hopper>                                           
                     Specify gpu architecture. Applicable for cuda and      
                     cudampi versions only. If unspecified, QUICK will be   
                     compiled for several architectures based on the CUDA   
                     toolkit version.                                       
      --ncores <ncore>                                                       
                     Specify the number of cores to be used in compilation. 
                     If unspecified, QUICK will attempt to automatically    
                     detect the number of cores in your system.             
      --enablef      Enables the compilation of time consuming f functions 
                     in the ERI code of cuda version.
      --amber        Install QUICK executables and libaries into AMBER. 
                     Requires specifying AMBER home directory as prefix. 
      --cew          Compiles source code necessary for CEW QM/MM with AMBER.
      --verbose      Enable full compilation output
      --lapack       Use matrix diagonalizer from LAPACK. BLASROOT environment
                     variable must be set with the correct blas installation path. 
                     This path must contain lib and include directories.  
      --mkl          Use matrix diagonalizer from MKL. MKLROOT environment
                     variable must be set with the correct mkl installation path.
                     This path must contain lib and include directories.
      --mirp         Use Boys function for ERI calculations from mirp library. 
                     MIRP_HOME and MIRP_DEP_HOME environment variables must be set to 
                     mirp and dependency installation directories. These paths must 
                     contain lib and include directories.

  Supported compilers are: gnu, intel, pgi, clang, nvidia

  For example, cuda version with intel compiler tool chain can be compiled as
  follows:
         ./configure --cuda --arch volta --prefix /home/install intel
  "

exit 0;

}

# this function checks if we should link libmpi_cxx.so in the mpi/cudampi version
set_mpicxx(){

  mpi_cxx_flag=''

  # clean test files if they already exist
  rm -f test_mpicxx.c test_prog.f90 test_mpicxx.o test_prog.o test_prog

  # create the dummy source files
  cat > test_mpicxx.c << EOF
  #include <mpi.h>
  void test_func(){MPI_Init(NULL, NULL); MPI_Finalize();}
  extern "C" {void test_func_(){test_func();}}
EOF

  cat > test_prog.f90 << EOF
  program test
    call test_func()
  end program test
EOF

  # compile the test sources
  $cxx -c test_mpicxx.c -o test_mpicxx.o 2>/dev/null >/dev/null
  if [ "$?" -ne 0 ]; then
    echo  "Error: MPI/C++ source cannot be compiled using $cxx "
    echo ""
    exit 1
  fi

  $fort -c test_prog.f90 -o test_prog.o 2>/dev/null >/dev/null
  if [ "$?" -ne 0 ]; then
    echo  "Error: Fortran90 source cannot be compiled using $fort "
    echo ""
    exit 1
  fi

  # try to link the object files without -lmpi_cxx and if it doesnt work set mpi_cxx_flag.
  $fort test_mpicxx.o test_prog.o -o testmpi $ldflags 2>/dev/null >/dev/null
  if [ "$?" -ne 0 ]; then
    mpi_cxx_flag="-lmpi_cxx"
  fi

  # hipmpi version requires linking objects using hipcc. 
  if [ "$hipmpi" = 'yes' ]; then

    hip_mpi_flags=`$fort -show`
    hip_mpi_flags=`echo "$hip_mpi_flags" | cut -d ' ' -f2-`
  fi

  #try to link with libmpi_cxx
  $fort test_mpicxx.o test_prog.o -o testmpi $ldflags $mpi_cxx_flag 2>/dev/null >/dev/null
  if [ "$?" -ne 0 ]; then
    echo  "Error: Fortran90 and C++ code cannot be linked using $fort $ldflags $mpi_cxx_flag "
    echo  "Try to check the commands using 'mpif90 -show' "
    exit 1
  fi

  ldflags="$ldflags $mpi_cxx_flag"

  rm -f test_mpicxx.c test_prog.f90 test_mpicxx.o test_prog.o testmpi


}

# this function checks for the operating system
check_os(){

  case "$OSTYPE" in
    linux*)   osname='linux';;
    darwin*)  osname='osx';;
    bsd)*     osname='bsd';;
    solaris*) osname='solaris';;
    *)        osname="unknown";;
  esac

  if [ -z `echo "$OSTYPE"` ]; then
    echo "Operating system: unknown"
  else
    echo "Operating system: $OSTYPE"
  fi
}

# this function print compiler mistmach
print_compiler_mistmatch(){
  echo  "Error: Compiler version mistmatch."
  echo  "       Fortran compiler version: $fort_version."
  echo  "       C compiler version: $cc_version."
  echo  "       C++ compiler version: $cxx_version."
}

# check compiler
check_compiler(){

# variables to assist detecting compiler versions
fort_search=''
cc_search=''
cxx_search=''

case "$compiler" in

  gnu)
    echo "Requested compiler: GNU."

    if [ "$mpi" = 'no' ] && [ "$cudampi" = 'no' ] && [ "$hipmpi" = 'no' ]; then
      if [ -z "$FC" ]; then fort='gfortran'; else fort="$FC";fi
      if [ -z "$CC" ]; then cc='gcc'; else cc="$CC";fi
      if [ -z "$CXX" ]; then cxx='g++'; else cxx="$CXX";fi
    else
      if [ -z "$MPIF90" ]; then fort='mpif90'; else fort="$MPIF90";fi
      if [ -z "$MPICC" ]; then cc='mpicc'; else cc="$MPICC";fi
      if [ -z "$MPICXX" ]; then cxx='mpicxx'; else cxx="$MPICXX";fi
    fi

    fort_search='gcc'
    cc_search='gcc'
    cxx_search='gcc'
    ;;

  intel)
    echo "Requested compiler: Intel"

    if [ "$mpi" = 'no' ] && [ "$cudampi" = 'no' ] && [ "$hipmpi" = 'no' ]; then
      if [ -z "$FC" ]; then fort='ifort'; else fort="$FC";fi
      if [ -z "$CC" ]; then cc='icc'; else cc="$CC";fi
      if [ -z "$CXX" ]; then cxx='icpc'; else cxx="$CXX";fi
    else
      if [ -z "$MPIF90" ]; then fort='mpiifort'; else fort="$MPIF90";fi
      if [ -z "$MPICC" ]; then cc='mpiicc'; else cc="$MPICC";fi
      if [ -z "$MPICXX" ]; then cxx='mpiicpc'; else cxx="$MPICXX";fi
    fi

    fort_search='ifort'
    cc_search='icc'
    cxx_search='icpc'
    ;;

  pgi)
    echo "Requested compiler: PGI."

    if [ "$mpi" = 'no' ] && [ "$cudampi" = 'no' ] && [ "$hipmpi" = 'no' ]; then
      if [ -z "$FC" ]; then fort='pgfortran'; else fort="$FC";fi
      if [ -z "$CC" ]; then cc='pgcc'; else cc="$CC";fi
      if [ -z "$CXX" ]; then cxx='pgc++'; else cxx="$CXX";fi
    else
      if [ -z "$MPIF90" ]; then fort='mpif90'; else fort="$MPIF90";fi
      if [ -z "$MPICC" ]; then cc='mpicc'; else cc="$MPICC";fi
      if [ -z "$MPICXX" ]; then cxx='mpicxx'; else cxx="$MPICXX";fi
    fi

    fort_search='pgfortran'
    cc_search='pgcc'
    cxx_search='pgc++'
    ;;

  clang)
    echo "Requested compiler: Clang."

    if [ "$mpi" = 'no' ] && [ "$cudampi" = 'no' ] && [ "$hipmpi" = 'no' ]; then
      if [ -z "$FC" ]; then fort='gfortran'; else fort="$FC";fi
      if [ -z "$CC" ]; then cc='clang'; else cc="$CC";fi
      if [ -z "$CXX" ]; then cxx='clang++'; else cxx="$CXX";fi
    else
      if [ -z "$MPIF90" ]; then fort='mpif90'; else fort="$MPIF90";fi
      if [ -z "$MPICC" ]; then cc='mpicc'; else cc="$MPICC";fi
      if [ -z "$MPICXX" ]; then cxx='mpicxx'; else cxx="$MPICXX";fi
    fi

    fort_search='gcc'
    cc_search='clang'
    cxx_search='clang'
    ;;

  nvidia)
    echo "Requested compiler: NVIDIA."

    if [ "$hip" = 'yes' ] || [ "$hipmpi" = 'yes' ]; then
      echo  "Error: NVIDIA compiler cannot be used with hip/hipmpi version."
      exit 1
    fi

    if [ "$mpi" = 'no' ] && [ "$cudampi" = 'no' ]; then
      if [ -z "$FC" ]; then fort='nvfortran'; else fort="$FC";fi
      if [ -z "$CC" ]; then cc='nvc'; else cc="$CC";fi
      if [ -z "$CXX" ]; then cxx='nvc++'; else cxx="$CXX";fi
    else
      if [ -z "$MPIF90" ]; then fort='mpif90'; else fort="$MPIF90";fi
      if [ -z "$MPICC" ]; then cc='mpicc'; else cc="$MPICC";fi
      if [ -z "$MPICXX" ]; then cxx='mpicxx'; else cxx="$MPICXX";fi
    fi

    fort_search='nvfortran'
    cc_search='nvc'
    cxx_search='nvc++'
    ;;

  *)
    echo  "Error: $compiler compiler tool chain is not supported."
    exit 1;;
esac

# check for the existance of each compiler
if [ -z "`which $fort 2> /dev/null`" ]; then
  echo  "Error: $fort is not found."
  exit 1
fi

if [ -z "`which $cc 2> /dev/null`" ]; then
  echo  "Error: $cc is not found."
  exit 1
fi

if [ -z "`which $cxx 2> /dev/null`" ]; then
  echo  "Error: $cxx is not found."
  exit 1
fi

# check for hipcc compiler
if [ "$hip" = 'yes' ] || [ "$hipmpi" = 'yes' ]; then
  hipcc='hipcc'
  if [ -z "`which $hipcc 2> /dev/null`" ]; then
    echo  "Error: $hipcc is not found."
    exit 1
  fi
fi

# general vars for compiler search
info_option='-v'
patch_seperator='.'
version_string="[0-9]{1,4}.[0-9]{1,4}$patch_seperator[0-9]{1,4}"

# pgi compilers use a different versioning output
if [ "$fort_search" = 'pgfortran' ] || [ "$fort_search" = 'nvfortran' ]; then
  patch_seperator='-'
  version_string='[0-9]{1,4}.[0-9]{1,4}-[0-9]{1,4}'
  info_option='--version'
fi

# check the fortran compiler version
has_fort_version='no'
fort_version='not'
fort_version_major=''
fort_version_minor=''
fort_version_patch=''
fort_search_string="$fort_search\s[vV]ersion\s$version_string"

# pgi & nvidia compilers use a different version output
if [ "$fort_search" = 'pgfortran' ] || [ "$fort_search" = 'nvfortran' ]; then
  fort_search_string="$fort_search\s$version_string"
fi

fort_version_info=`$fort_search $info_option 2>&1 | grep -oE "$fort_search_string"`

# some gnu installations gives off 'gcc version xx.xx.xx' instead of 'gfortran version xx.xx.xx'
if [ -z "$fort_version_info" ]; then
  fort_search_string="$cc_search\s[vV]ersion\s$version_string"
  fort_version_info=`$fort_search $info_option 2>&1 | grep -oE "$fort_search_string"`
fi

fort_version=`echo $fort_version_info | grep -oE "$version_string"`

if [ `echo $fort_version | grep -oE "$version_string" | wc -l` -gt 0 ]; then
  has_fort_version='yes'
  fort_version_major=`echo $fort_version | cut -d '.' -f1`
  fort_version_minor=`echo $fort_version | cut -d '.' -f2`
  fort_version_patch=`echo $fort_version | cut -d "$patch_seperator" -f3`
fi

if [ "$has_fort_version" = 'yes' ]; then
  echo "  $fort version $fort_version found.."
else
   echo  "Warning: Failed to detect $fort version."
fi

if [ "$fort_search" = 'gfortran' ] && [ "$fort_version_major" -ge 10 ]; then
  fort_vspec_flags='-fallow-argument-mismatch'
fi

# check the c compiler version
has_cc_version='no'
cc_version='not'
cc_version_major=''
cc_version_minor=''
cc_version_patch=''
cc_search_string="$cc_search\s[vV]ersion\s$version_string"

# pgi & nvidia compilers use a different version output
if [ "$cc_search" = 'pgcc' ] || [ "$cc_search" = 'nvc' ]; then
  cc_search_string="$cc_search\s$version_string"
fi

cc_version_info=`$cc_search $info_option 2>&1 | grep -oE "$cc_search_string"`
cc_version=`echo $cc_version_info | grep -oE "$version_string"`

if [ `echo $cc_version | grep -oE "$version_string" | wc -l` -gt 0 ]; then
  has_cc_version='yes'
  cc_version_major=`echo $cc_version | cut -d '.' -f1`
  cc_version_minor=`echo $cc_version | cut -d '.' -f2`
  cc_version_patch=`echo $cc_version | cut -d "$patch_seperator" -f3`
fi

if [ "$has_cc_version" = 'yes' ]; then
  echo "  $cc version $cc_version found.."
else
   echo  "Warning: Failed to detect $cc version."
fi

if [ "$os_name" = 'osx' ] && [ `echo $cc_version | grep -oE "$version_string" | wc -l` -lt 1 ] ; then
  cc_version=`$cc_search -v 2>&1 | grep -oE "$version_string" | tail -1`
  if [ `"$cc_search" -v 2>&1 | grep "clang"` -gt 0 ]; then
    echo  "Error: $cc compiler was requested but clang c compiler is loaded."
    echo  "       Please load the correct compiler."
    exit 1
  fi
fi

# check the cxx compiler version
has_cxx_version='no'
cxx_version='not'
cxx_version_major=''
cxx_version_minor=''
cxx_version_patch=''
cxx_search_string="$cxx_search\s[vV]ersion\s$version_string"

# pgi & nvidia compilers use a different version output
if [ "$cxx_search" = 'pgc++' ]; then
  cxx_search_string="pgc\+\+\s$version_string"
fi

if [ "$cxx_search" = 'nvc++' ]; then
  cxx_search_string="nvc\+\+\s$version_string"
fi


cxx_version_info=`$cxx_search $info_option 2>&1 | grep -oE "$cxx_search_string"`

# some gnu installations gives off 'gcc version xx.xx.xx' instead of 'g++ version xx.xx.xx'
if [ -z "$cxx_version_info" ]; then
  cxx_version_info=`$cxx_search $info_option 2>&1 | grep -oE "$cc_search\s[vV]ersion\s$version_string"`
fi

cxx_version=`echo $cxx_version_info | grep -oE "$version_string"`

if [ `echo $cxx_version | grep -oE "$version_string" | wc -l` -gt 0 ]; then
  has_cxx_version='yes'
  cxx_version_major=`echo $cxx_version | cut -d '.' -f1`
  cxx_version_minor=`echo $cxx_version | cut -d '.' -f2`
  cxx_version_patch=`echo $cxx_version | cut -d "$patch_seperator" -f3`
fi

if [ "$has_cxx_version" = 'yes' ]; then
  echo "  $cxx version $cxx_version found.."
else
   echo  "Warning: Failed to detect $cxx version."
fi

if [ "$os_name" = 'osx' ] && [ `echo $cxx_version | grep -oE "$version_string" | wc -l` -lt 1 ] ; then
  cxx_version=`$cxx_search -v 2>&1 | grep -E "$cxx_search | [vV]ersion " | grep -oE "$version_string" | tail -1`
  if [ `"$cxx_search" -v 2>&1 | grep "clang"` > 0 ]; then
    echo  "Error: $cxx compiler was requested but clang c++ compiler is loaded."
    echo  "       Please load the correct compiler."
    exit 1
  fi
fi

# check for version compatibility
if [ "$has_fort_version" = 'yes' ] && [ "$has_cc_version" = 'yes' ] && [ "$has_cxx_version" = 'yes' ]; then
  if [ ! "$fort_version_major" = "$cc_version_major" ] && [ ! "$fort_version_major" = "$cxx_version_major" ]; then
     print_compiler_mistmatch
     exit 1
   elif [ ! "$fort_version_minor" = "$cc_version_minor" ] && [ ! "$fort_version_minor" = "$cxx_version_minor" ]; then
     print_compiler_mistmatch
     exit 1
   elif [ ! "$fort_version_patch" = "$cc_version_patch" ] && [ ! "$fort_version_patch" = "$cxx_version_patch" ]; then
    print_compiler_mistmatch
    exit 1
  fi
fi


}


#  !---------------------------------------------------------------------!
#  ! External library checking                                           !
#  !---------------------------------------------------------------------!

# Function to check for mkl library and dependencies.
check_mkl(){
  if [ -z $MKLROOT ]; then
    echo "MKL is not loaded. Inbuilt diagonalizer will be used."
    return 1
  fi

  MKLLIBPATH=$MKLROOT/lib/intel64
  if [ ! -e "$MKLLIBPATH/libmkl_intel_lp64.so" ]; then
    echo "libmkl_intel_lp64.so cannot be found. Inbuilt diagonalizer will be used."
    return 1
  fi

  if [ ! -e "$MKLLIBPATH/libmkl_intel_thread.so" ]; then
    echo "libmkl_intel_thread.so cannot be found. Inbuilt diagonalizer will be used."
    return 1
  fi

  if [ ! -e "$MKLLIBPATH/libmkl_core.so" ]; then
    echo "libmkl_core.so cannot be found. Inbuilt diagonalizer will be used."
    return 1
  fi

}


# Function to check for lapack library and dependencies.
check_lapack(){

  if [ ! -z "$BLASROOT" ]; then
    if [ ! -e "$BLASROOT/lib/libopenblas.so" ]; then
      echo "libopenblas.so cannot be found. Inbuilt diagonalizer will be used."
      return 1
    fi
  else
    echo "OPENBLAS is not loaded. Inbuilt diagonalizer will be used."
    return 1
  fi
}

# Function to check for MIRP library and dependencies. 
check_mirp(){

if [ "$mirp" = 'yes' ] && [ "$shared" = 'no' ]; then
  echo "Error: MIRP requires --shared flag. Plese reconfigure."
  exit 1
fi

if [ -z "$MIRP_HOME" ]; then
  echo "Error: MIRP_HOME is not set!"
  exit 1
else
 # check for the so library
  if [ ! -e "$MIRP_HOME/lib/libmirp.so" ]; then
    echo "Error: libmirp.so cannot be found!"
    exit 1
  fi
fi

# check for dependencies
if [ -z "$MIRP_DEP_HOME" ]; then
  echo "Error: MIRP_DEP_HOME is not set!"
  exit 1
else

# check for libarb.so
if [ ! -e "$MIRP_DEP_HOME/lib/libarb.so" ]; then
   echo "Error: libarb.so cannot be found!"
   exit 1
fi

# check for libgmp.so
if [ ! -e "$MIRP_DEP_HOME/lib/libgmp.so" ]; then
   echo "Error: libgmp.so cannot be found!"
   exit 1
fi

# check for libmpfr.so
if [ ! -e "$MIRP_DEP_HOME/lib/libmpfr.so" ]; then
   echo "Error: libmpfr.so cannot be found!"
   exit 1
fi

# check for libflint.so
if [ ! -e "$MIRP_DEP_HOME/lib/libflint.so" ]; then
   echo "Error: libflint.so cannot be found!"
   exit 1
fi

fi

}


#  !---------------------------------------------------------------------!
#  ! Variable definitions                                                !
#  !---------------------------------------------------------------------!

# quick version flags
serial='no'
mpi='no'
cuda='no'
cudampi='no'
hip='no'
hipmpi='no'
debug='no'
debugtime='no'
profile='no'
buildtypes=''
installers=''

# keeps track of what compilers being used
fort='no'
cc='no'
cxx='no'
nvcc='no'
hipcc='no'

# where to install
useprefix='false'
quick_prefix="$QUICK_HOME"

# operating system
osname=''

# flag to indicate if a so library compilation is required
shared='no'

# compiler specific flags
fort_flags=''
cc_flags=''
cxx_flags=''
cuda_flags=''
cpp_flags=''
hip_flags=''

# archiver related variables
arch='ar'
arch_flags='cr'
ranlib='ranlib'
libext='a'

# linker flags
ldflags=''
cflags=''

# optimization levels
opt_flags='-O2'
blas_opt_flags='-O3'

# cuda/hip architecture flags
uspec_arch='false'
cuda_arch=''
cuda_arch_flags=''
hip_arch=''
hip_arch_flags=''

# extra cuda flags
cuda_ext_flags='-m64 -use_fast_math'
cuda_dc_flags=''
hip_ext_flags='-ffast-math'
hip_dc_flags=''
hip_ld_flags=''

# cuda include flags
cuda_incl_flags=''
hip_incl_flags=''

# flags to generate PIC in so library case
lib_flags=''
cuda_lib_flags=''
hip_lib_flags=''
hip_mpi_flags=''

# debug flags
fort_debug_flags=''
cc_debug_flags=''
cxx_debug_flags=''
cuda_debug_flags=''

# profile flags
fort_profile_flags=''
cc_profile_flags=''
cxx_profile_flags=''
cuda_profile_flags=''

# compiler version specific flags
fort_vspec_flags=''

# external library specific flags
fort_ext_lib_flags=''

# set common folders
libxcobjfolder=''
libxcdevobjfolder=''
blasobjfolder=''
lapackoobjfolder=''
dlfindobjfolder=''
dftd3objfolder=''

# keep track of which build types to clean
cleantypes=''

# keep track of which versions to install and uninstall
installtypes=''
uninstalltypes=''

# keep track of type of testing (i.e. build or install)
testtype='buildtest'

# numbers of cores to be used for make
uspec_ncores='no'
ncores=''

# track if f functions should not be compiled in cuda version
enablef='no'

# amber related variables
aminstall='false'
cew='no'

# control compiler output
verbose='@'

# external math libraries
lapack='no'
mkl='no'

# flag for mirp library
mirp='no'

#  !---------------------------------------------------------------------!
#  ! Check user input                                                    !
#  !---------------------------------------------------------------------!
if [ $# -lt 1 ]; then print_help; fi

while [ $# -gt 0 ]; do
  case "$1" in
    --serial)      serial='yes'; buildtypes="$buildtypes serial"; cleantypes="$cleantypes serialclean"; installers="$installers quick";;
    --mpi)         mpi='yes'; buildtypes="$buildtypes mpi"; cleantypes="$cleantypes mpiclean"; installers="$installers quick.MPI";;
    --cuda)        cuda='yes'; buildtypes="$buildtypes cuda"; cleantypes="$cleantypes cudaclean"; installers="$installers quick.cuda";;
    --cudampi)     cudampi='yes'; buildtypes="$buildtypes cudampi"; cleantypes="$cleantypes cudampiclean"; installers="$installers quick.cuda.MPI";;
    --hip)         hip='yes'; buildtypes="$buildtypes hip"; cleantypes="$cleantypes hipclean"; installers="$installers quick.hip";;
    --hipmpi)      hipmpi='yes'; buildtypes="$buildtypes hipmpi"; cleantypes="$cleantypes hipmpiclean"; installers="$installers quick.hip.MPI";;
    --debug-time)  debugtime='yes';;
    --debug)       debug='yes';;
    --profile)     profile='yes';;
    --verbose)     verbose='';;
    --mirp)        mirp='yes';;
    --shared)      shared='yes';;
    --enablef)     enablef='yes';;
    --amber)       aminstall='true';;
    --cew)         cew='yes';;
    --lapack)      lapack='yes';;
    --mkl)         mkl='yes';;
    --arch)        shift; cuda_arch="$cuda_arch $1"; uspec_arch='true';;
    --ncores)      shift; ncores=$1; uspec_ncores='yes';;
    --prefix)      shift; quick_prefix=${1%/}; useprefix='true';;
    gnu)           compiler='gnu';;
    intel)         compiler='intel';;
    pgi)           compiler='pgi';;
    clang)         compiler='clang';;
    nvidia)        compiler='nvidia';;
    -h| -H| -help| --help) print_help;;
     *)  echo  "Error: $1 is an unknown flag."
         echo  "       Run this script as './configure [flags] compiler'."
         echo  "       Run './configure --help' for more information."
         exit 1;;
  esac
  shift
done

# check the build type
if [ -z "$buildtypes" ]; then
  echo "No build type specified."
  echo "Proceeding with a serial build."
  serial='yes'; buildtypes="$buildtypes serial"; cleantypes="$cleantypes serialclean"; installers="$installers quick"
else
  echo "Requested installation type/s: $buildtypes"
fi

# check the os first
check_os

if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ] || [ "$hip" = 'yes' ] || [ "$hipmpi" = 'yes' ] && [ ! "$osname" = 'linux' ]; then
  echo  "Warning: QUICK cuda/hip and cuda-mpi/hip-mpi versions have never been tested on $osname os."
fi

# check compiler
check_compiler

# check for dependencies
if [ "$mirp" = "yes" ]; then
  check_mirp
fi

# check is amber installtion is required
if [ "$aminstall" = "true" ]; then

  if [ "$useprefix" = "false" ]; then
    echo "Error: AMBER compatible installation requires specifying the AMBER home directory as prefix."
    exit 1
  fi

  # check for AMBER_HOME
  if [ ! -d "$quick_prefix/AmberTools" ]; then
    echo  "Error: Please provide the correct AMBER home directory."
    exit 1
  else
    # do this trick to get absolute path
    cd "$quick_prefix"
    quick_prefix=`pwd`
    cd "$QUICK_HOME"

    echo "QUICK will be installed into AMBER home directory $quick_prefix."

    installtypes='aminstall'
    uninstalltypes='amuninstall'

  fi

fi

# check prefix and perform necessary operations, we shall not create these for an amber installation
if [ "$useprefix" = "true" ] && [ "$aminstall" = "false" ]; then

  if [ "$QUICK_HOME" = "$quick_prefix" ]; then
    echo  "Error: Specified --prefix and current folder is the same. Please choose a different location. "
    exit 1
  elif [ ! -d "$quick_prefix" ]; then
    mkdir -p "$quick_prefix"
  fi

  # do this trick to get absolute path
  cd "$quick_prefix"
  quick_prefix=`pwd`
  cd "$QUICK_HOME"

  echo "QUICK will be installed in $quick_prefix"

  # create tests and basis directories if they dont exist
  if [ ! -d "$quick_prefix/test" ]; then
    mkdir -p "$quick_prefix/test"

    # delete the runs directory from QUICK_HOME/test if it exists
    if [ -d "$QUICK_HOME/test/runs" ]; then rm -rf $QUICK_HOME/test/runs; fi

    # Copy test folder from QUICK_HOME to install folder.
    echo "Copying test cases into $quick_prefix/test"
    cp -rf "$QUICK_HOME/test/"* "$quick_prefix/test/"

  fi

  # copy the contents of basis folder since user may delete/relocate
  # QUICK_HOME folder after installation
  if [ ! -d "$quick_prefix/basis" ]; then
    mkdir -p "$quick_prefix/basis"
    cp -rf "$QUICK_HOME/basis/"* "$quick_prefix/basis/"
  fi

  # create bin, lib and include directories
  if [ ! -d "$quick_prefix/bin" ]; then
    mkdir -p "$quick_prefix/bin"
  fi

  for buildtype in $buildtypes; do
    if [ ! -d "$quick_prefix/lib/$buildtype" ]; then
      mkdir -p "$quick_prefix/lib/$buildtype"
    fi

    if [ ! -d "$quick_prefix/include/$buildtype" ]; then
      mkdir -p "$quick_prefix/include/$buildtype"
    fi
  done

  # create common include folder
  if [ ! -d "$quick_prefix/include/common" ]; then
    mkdir -p "$quick_prefix/include/common"
  fi

  # set install and uninstall types
  install_string='install'
  uninstall_string='uninstall'

  for buildtype in $buildtypes; do
    installtypes="$installtypes $buildtype$install_string"
    uninstalltypes="$uninstalltypes $buildtype$uninstall_string"
  done
fi

if [ "$useprefix" = "false" ]; then
  echo "No prefix specified for the installation."
  installtypes='noinstall'
  uninstalltypes='nouninstall'
fi


#  !---------------------------------------------------------------------!
#  ! Create essential build directories                                  !
#  !---------------------------------------------------------------------!

if [ ! -d "$QUICK_HOME/bin" ]; then
  mkdir -p "$QUICK_HOME/bin"
fi

for buildtype in $buildtypes; do
  if [ ! -d "$QUICK_HOME/build/lib/$buildtype" ]; then
    mkdir -p "$QUICK_HOME/build/lib/$buildtype"
  fi

  if [ ! -d "$QUICK_HOME/build/include/$buildtype" ]; then
    mkdir -p "$QUICK_HOME/build/include/$buildtype"
  fi

  if [ ! -d "$QUICK_HOME/build/obj/$buildtype" ]; then
    mkdir -p "$QUICK_HOME/build/obj/$buildtype"
  fi

  if [ ! -d "$QUICK_HOME/build/obj/$buildtype/main" ]; then
    mkdir -p "$QUICK_HOME/build/obj/$buildtype/main"
  fi

  if [ "$buildtype" = 'serial' -o "$buildtype" = 'mpi' -o "$buildtype" = 'hip' -o "$buildtype" = 'hipmpi' ]; then
    if [ ! -d "$QUICK_HOME/build/common/cpu/libxcobj" ]; then
      mkdir -p "$QUICK_HOME/build/common/cpu/libxcobj"
    fi
    libxcobjfolder="$QUICK_HOME/build/common/cpu/libxcobj"

  fi

  if [ "$buildtype" = 'cuda' -o "$buildtype" = 'cudampi' -o "$buildtype" = 'hip' -o "$buildtype" = 'hipmpi' ]; then
    if [ ! -d "$QUICK_HOME/build/common/gpu/libxcobj" ]; then
      mkdir -p "$QUICK_HOME/build/common/gpu/libxcobj"
    fi
    libxcobjfolder="$QUICK_HOME/build/common/gpu/libxcobj"

    if [ ! -d "$QUICK_HOME/build/common/gpu/libxcdevobj" ]; then
      mkdir -p "$QUICK_HOME/build/common/gpu/libxcdevobj"
    fi
    libxcdevobjfolder="$QUICK_HOME/build/common/gpu/libxcdevobj"

  fi

  # create blasobj directory
  if [ ! -d "$QUICK_HOME/build/common/cpu/blasobj" ]; then
    mkdir -p "$QUICK_HOME/build/common/cpu/blasobj"
  fi
  blasobjfolder="$QUICK_HOME/build/common/cpu/blasobj"

  # create lapackobj directory
  if [ ! -d "$QUICK_HOME/build/common/cpu/lapackobj" ]; then
    mkdir -p "$QUICK_HOME/build/common/cpu/lapackobj"
  fi
  lapackobjfolder="$QUICK_HOME/build/common/cpu/lapackobj"
  
  # create dlfindobj directory
  if [ ! -d "$QUICK_HOME/build/common/cpu/dlfindobj" ]; then
    mkdir -p "$QUICK_HOME/build/common/cpu/dlfindobj" 
  fi
  dlfindobjfolder="$QUICK_HOME/build/common/cpu/dlfindobj"

  # create dftd3objfolder directory
  if [ ! -d "$QUICK_HOME/build/common/cpu/dftd3obj" ]; then
    mkdir -p "$QUICK_HOME/build/common/cpu/dftd3obj"
  fi
  dftd3objfolder="$QUICK_HOME/build/common/cpu/dftd3obj"

done

# create common include folder
if [ ! -d "$QUICK_HOME/build/include/common" ]; then
  mkdir -p "$QUICK_HOME/build/include/common"
fi

#  !---------------------------------------------------------------------!
#  ! Query system information                                            !
#  !---------------------------------------------------------------------!

# set number of cores for the compilation
  if [ "$uspec_ncores" = 'yes' ]; then
    echo "Number of cores requested for the compilation: $ncores"
  else
    if [ `command -v nproc | wc -l` -gt 0 ]; then
      ncores=`nproc --all`
      echo "A total of $ncores cores will be used for the compilation."
    else
      ncores=1
      echo "Only a single core will be used for the compilation."
    fi
  fi

#  !---------------------------------------------------------------------!
#  ! Check for CUDA tool kit and compiler                                !
#  !---------------------------------------------------------------------!

# this function sets the user defined cuda architecture flags, if specified
set_uspec_arch(){
  for carch in $cuda_arch; do
    case "$carch" in
      kepler)
	echo "Configuring for SM3.5"
	cuda_arch_flags="$cuda_arch_flags $sm35flags -DUSE_LEGACY_ATOMICS"
	cuda_dc_flags='-Xptxas --disable-optimizer-constants';;
      maxwell)
        echo "Configuring for SM5.0"
        cuda_arch_flags="$cuda_arch_flags $sm50flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants';;
      pascal)
        echo "Configuring for SM6.0"
        cuda_arch_flags="$cuda_arch_flags $sm60flags"
		cuda_dc_flags='-Xptxas --disable-optimizer-constants';;
      volta)
        echo "Configuring for SM7.0"
        cuda_arch_flags="$cuda_arch_flags $sm70flags"
		if [ `echo "$cudaversion < 10.0 "| bc` -gt 0 ]; then
		  cuda_dc_flags='-Xptxas --disable-optimizer-constants'
		fi
		;;
      turing)
        echo "Configuring for SM7.5"
        cuda_arch_flags="$cuda_arch_flags $sm75flags";;
      ampere)
        echo "Configuring for SM8.0"
        cuda_arch_flags="$cuda_arch_flags $sm80flags";;
      adalovelace)
        echo "Configuring for SM8.9"
        cuda_arch_flags="$cuda_arch_flags $sm89flags";;
      hopper)
        echo "Configuring for SM9.0"
        cuda_arch_flags="$cuda_arch_flags $sm90flags";;
    esac
  done
}

if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ]; then
  if [ -z "$CUDA_HOME" ]; then
    echo  "Error: CUDA_HOME environment variable is not set."
    echo  "Please make sure CUDA toolkit is loaded."
    exit 1
  fi

  if [ ! -x "$CUDA_HOME/bin/nvcc" ]; then
    echo  "Error: nvcc compiler is not available in $CUDA_HOME/bin/"
    exit 1
  fi

  if [ -z "$NVCC" ]; then nvcc="$CUDA_HOME/bin/nvcc"; else nvcc="$NVCC"; fi
  #SM9.0 = H100, GH200 (Hopper)
    sm90flags='-gencode arch=compute_90,code=sm_90'
    #SM8.9 = L4, L400 (Ada Lovelace)
    sm89flags='-gencode arch=compute_89,code=sm_89'
    #SM8.6 = A2, A10, A16, A40 (Ampere)
    sm86flags='-gencode arch=compute_86,code=sm_86'
    #SM8.0 = A30, A100 (Ampere)
    sm80flags='-gencode arch=compute_80,code=sm_80'
    #SM7.5 = RTX20xx, Tesla T4, Quadro RTX, RTX Titan (Turing)
    sm75flags='-gencode arch=compute_75,code=sm_75'
    #SM7.0 = V100, Titan V (Volta)
    sm70flags='-gencode arch=compute_70,code=sm_70'
    #SM6.0 = GP100 / P100 = DGX-1 (Pascal)
    sm60flags='-gencode arch=compute_60,code=sm_60'
    #SM5.0 = M40 (Maxwell)
    sm50flags='-gencode arch=compute_50,code=sm_50'
    #SM3.7 = GK210 = K80 -- not currently used, since SM3.0 may be better (Kepler)
    sm37flags='-gencode arch=compute_37,code=sm_37'
    #SM3.5 = GK110 + 110B = K20, K20X, K40, GTX780, GTX-Titan, GTX-Titan-Black, GTX-Titan-Z (Kepler)
    sm35flags='-gencode arch=compute_35,code=sm_35'
    #SM3.0 = GK104 = K10, GTX680, 690 etc. (Kepler)
    sm30flags='-gencode arch=compute_30,code=sm_30'

    cudaversion=`$nvcc --version | grep 'release' | cut -d' ' -f5 | cut -d',' -f1`

    if [ "$cudaversion" = "12.0" -o "$cudaversion" = "12.1" -o "$cudaversion" = "12.2" -o "$cudaversion" = "12.3" ]; then

      echo "CUDA Version $cudaversion detected"

      if [ "$uspec_arch" = 'true' ]; then
        set_uspec_arch
      else

        echo "Configuring for SM5.0, SM6.0, SM7.0, SM7.5, SM8.0, SM8.6, SM8.9, SM9.0"
        cuda_arch_flags="$sm50flags $sm60flags $sm70flags $sm75flags $sm80flags $sm86flags $sm89flags $sm90flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants'
      fi
    elif [ "$cudaversion" = "11.8" ]; then

      echo "CUDA Version $cudaversion detected"

      if [ "$uspec_arch" = 'true' ]; then
        set_uspec_arch
      else

        echo "Configuring for SM3.5, SM3.7, SM5.0, SM6.0, SM7.0, SM7.5, SM8.0, SM8.6, SM8.9, SM9.0"
        cuda_arch_flags="$sm35flags $sm37flags $sm50flags $sm60flags $sm70flags $sm75flags $sm80flags $sm86flags $sm89flags $sm90flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants'
      fi
    elif [ "$cudaversion" = "11.1" -o "$cudaversion" = "11.2" -o "$cudaversion" = "11.3" -o "$cudaversion" = "11.4" -o "$cudaversion" = "11.5" -o "$cudaversion" = "11.6" -o "$cudaversion" = "11.7" ]; then

      echo "CUDA Version $cudaversion detected"

      if [ "$uspec_arch" = 'true' ]; then
        set_uspec_arch
      else

        echo "Configuring for SM3.5, SM3.7, SM5.0, SM6.0, SM7.0, SM7.5, SM8.0, SM8.6"
        cuda_arch_flags="$sm35flags $sm37flags $sm50flags $sm60flags $sm70flags $sm75flags $sm80flags $sm86flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants'
      fi
    elif [ "$cudaversion" = "11.0" ]; then

      echo "CUDA Version $cudaversion detected"

      if [ "$uspec_arch" = 'true' ]; then
        set_uspec_arch
      else

        echo "Configuring for SM3.0, SM3.5, SM3.7, SM5.0, SM6.0, SM7.0, SM7.5, SM8.0"
        cuda_arch_flags="$sm30flags $sm35flags $sm37flags $sm50flags $sm60flags $sm70flags $sm75flags $sm80flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants'
      fi
    elif [ "$cudaversion" = "10.0" -o "$cudaversion" = "10.1" -o "$cudaversion" = "10.2" ]; then
      echo "CUDA Version $cudaversion detected"

      if [ "$uspec_arch" = 'true' ]; then
        set_uspec_arch
      else
        echo "Configuring for SM3.0, SM5.0, SM6.0, SM7.0 and SM7.5"
        cuda_arch_flags="$sm30flags $sm50flags $sm60flags $sm70flags $sm75flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants'
      fi
    elif [ "$cudaversion" = "9.0" -o "$cudaversion" = "9.1" -o "$cudaversion" = "9.2" ]; then
      echo "CUDA Version $cudaversion detected"

      if [ "$uspec_arch" = 'true' ]; then
        set_uspec_arch
      else
        echo "Configuring for SM3.0, SM5.0, SM6.0 and SM7.0"
        cuda_arch_flags="$sm30flags $sm50flags $sm60flags $sm70flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants'
      fi
    elif [ "$cudaversion" = "8.0" ]; then
      echo "CUDA Version $cudaversion detected"

      if [ "$uspec_arch" = 'true' ]; then
        set_uspec_arch
      else
        echo "Configuring for SM3.0, SM5.0, SM6.0"
        cuda_arch_flags="$sm30flags $sm50flags $sm60flags -DUSE_LEGACY_ATOMICS"
        cuda_dc_flags='-Xptxas --disable-optimizer-constants'
      fi
    else
      echo  "Error: Unsupported CUDA version $cudaversion detected. "
      echo  "       QUICK requires CUDA version >= 8.0 and <= 12.3.  Please upgrade your CUDA installation or disable building with CUDA. "
      exit 1
    fi

    if [ -z $verbose ]; then
      cuda_ext_flags="-Xptxas=-v $cuda_ext_flags" 
    fi

fi

#  !---------------------------------------------------------------------!
#  ! Check for HIP tool kit and compiler                                 !
#  !---------------------------------------------------------------------!

# this function sets the user defined cuda architecture flags, if specified
set_uspec_hip_arch(){
  for carch in $cuda_arch; do
    case "$carch" in
      gfx906)
        echo "Configuring for gfx906"
        hip_arch_flags="$hip_arch_flags -offload-arch=gfx906 -DUSE_LEGACY_ATOMICS";;
      gfx908)
        echo "Configuring for gfx908"
        hip_arch_flags="$hip_arch_flags -offload-arch=gfx908 -DUSE_LEGACY_ATOMICS";;
      gfx90a)
        echo "Configuring for gfx90a"
        hip_arch_flags="$hip_arch_flags -offload-arch=gfx90a -munsafe-fp-atomics -DAMD_ARCH_GFX90a";;
    esac
  done

}

if [ "$hip" = 'yes' ] || [ "$hipmpi" = 'yes' ]; then
  echo  "Error: HIP support is currently unavailable in this QUICK release. "
  echo  "       Support will be added back in a future release. "
  exit 1

  if [ -z "$ROCM_PATH" ]; then
    echo  "Error: ROCM_PATH environment variable is not set."
    echo  "Please make sure ROCm toolkit is loaded."
    exit 1
  fi

  if [ ! -x "$ROCM_PATH/hip/bin/hipcc" ]; then
    echo  "Error: hipcc compiler is not available in $ROCM_PATH/hip/bin/"
    exit 1
  fi

  if [ -z "$HIPCC" ]; then hipcc="$ROCM_PATH/hip/bin/hipcc"; else hipcc="$HIPCC"; fi


    hipversion_str=`$hipcc --version | grep 'HIP version:' | cut -d' ' -f3 `
    hipversion_major=`echo $hipversion_str | cut -d '.' -f1`
    hipversion_minor=`echo $hipversion_str | cut -d '.' -f2`
    hipversion="$hipversion_major.$hipversion_minor"

    if [ "$hipversion_major" -ge "4" ] && [ "$hipversion_minor" -ge "0" ]; then
      echo "HIP version $hipversion detected"
    else
      echo "Error: HIP version must be greater thant 4.4."
      exit 1
    fi

    # HIP codes currently do not support f-functions with -DUSE_LEGACY_ATOMICS targets (gfx906 and gfx908)
    if [ "$enablef" = 'yes' -a [ "$uspec_arch" -ne 'true' -o "$cuda_arch" = "gfx906" -o "$cuda_arch" = "gfx908" ] ]; then
      echo  "Error: Unsupported HIP options (ENABLEF with -DUSE_LEGACY_ATOMICS). "
      echo  "       QUICK support for f-functions requires newer HIP architecture targets not using LEGACY_ATOMICS. "
      echo  "       Please specify architectures with --arch not needing LEGACY_ATOMICS (post-gfx908) or disable f-function support. "
      exit 1
    fi

    set_uspec_hip_arch

    if [ -z $verbose ]; then
      hip_ext_flags="$hip_ext_flags -v"
    fi

fi

#  !---------------------------------------------------------------------!
#  ! Set common flags                                                    !
#  !---------------------------------------------------------------------!

# set debug flags
if [ "$debug" = 'yes' ]; then
  opt_flags='-O0'
  blas_opt_flags='-O0'

  case "$compiler" in
    gnu | pgi | clang | nvidia)
      fort_debug_flags='-g -DDEBUG -DDEBUGTIME'
      cc_debug_flags='-g -DDEBUG'
      cxx_debug_flags='-g -DDEBUG'
      ;;
    intel)
      fort_debug_flags='-g -traceback -DDEBUG -DDEBUGTIME'
      cc_debug_flags='-g -traceback -DDEBUG'
      cxx_debug_flags='-g -traceback -DDEBUG'
      ;;
  esac

  if [ "$cuda" = 'yes' -o "$cudampi" = 'yes' ]; then
    cuda_debug_flags='-g -DDEBUG'
  fi

  if [ "$hip" = 'yes' -o "$hipmpi" = 'yes' ]; then
    hip_debug_flags='-g -DDEBUG'
  fi

elif [ "$debugtime" = 'yes' ]; then
  fort_debug_flags='-DDEBUGTIME'
  if [ "$cuda" = 'yes' -o "$cudampi" = 'yes' ]; then
    cuda_debug_flags='-DDEBUGTIME'
  fi
  if [ "$hip" = 'yes' -o "$hipmpi" = 'yes' ]; then
    hip_debug_flags='-DDEBUGTIME'
  fi
fi

# set profile flags
if [ "$profile" = 'yes' ]; then
  if [ "$cuda" = 'yes' -o "$cudampi" = 'yes' ]; then
    cuda_profile_flags='--generate-line-info'
  fi
fi

# set library flags if so library is requested
if [ "$shared" = 'yes' ]; then
  lib_flags='-fPIC'
  cuda_lib_flags="--compiler-options '-fPIC'"
  arch="$fort"
  arch_flags='-shared -o'
  ranlib='echo'
  libext='so'

  if [ "$hip" = 'yes' -o "$hipmpi" = 'yes' ]; then
    echo  "Error: shared library support is not currently available for hip and hipmpi versions."
    exit 1
  fi

fi

#  !---------------------------------------------------------------------!
#  ! Set flags & generate make input files                               !
#  !---------------------------------------------------------------------!

for buildtype in $buildtypes; do

  # set compiler specific flags
  case "$compiler" in
    gnu)
      fort_flags="$opt_flags $fort_debug_flags -mtune=native -ffree-form -cpp -DGNU $fort_vspec_flags $lib_flags -I$QUICK_HOME/build/include/$buildtype -J$QUICK_HOME/build/include/$buildtype"
      if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ]; then
        cflags="-lgfortran -L$CUDA_HOME/lib64 -lcuda -lm -lcudart -lcudadevrt -lcublas -lcusolver"
		if [ `echo "$cudaversion < 10.0 "| bc` -gt 0 ]; then  
		  cflags="$cflags -fopenmp"
		fi
      fi
      ;;
    clang)
      fort_flags="$opt_flags $fort_debug_flags -mtune=native -ffree-form -cpp -DGNU $fort_vspec_flags $lib_flags -I$QUICK_HOME/build/include/$buildtype -J$QUICK_HOME/build/include/$buildtype"
      if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ]; then
        cflags="-lgfortran -L$CUDA_HOME/lib64 -lcuda -lm -lcudart -lcudadevrt -lcublas -lcusolver"
		if [ `echo "$cudaversion < 10.0 "| bc` -gt 0 ]; then  
		  cflags="$cflags -fopenmp"
		fi
      fi
      ;;
    intel)
      fort_flags="$opt_flags $fort_debug_flags -ip -cpp -diag-disable 8291 $lib_flags -I$QUICK_HOME/build/include/$buildtype -module $QUICK_HOME/build/include/$buildtype"
      if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ]; then
        cflags="-L$CUDA_HOME/lib64 -lcuda -lm -lcudart -lcudadevrt -lcublas -lcusolver"
		if [ `echo "$cudaversion < 10.0 "| bc` -gt 0 ]; then  
		  cflags="$cflags -L$MKLROOT/lib/intel64 -liomp5"
		fi	
      fi
      ;;
    pgi)
      fort_flags="$opt_flags $fort_debug_flags -m64 -cpp $lib_flags -I$QUICK_HOME/build/include/$buildtype -module $QUICK_HOME/build/include/$buildtype"
      if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ]; then
        cflags="-L$CUDA_HOME/lib64 -lcuda -lm -lcudart -lcudadevrt -lcublas -lcusolver"
      fi
      ;;
    nvidia)
      fort_flags="$opt_flags $fort_debug_flags -m64 -cpp $lib_flags -I$QUICK_HOME/build/include/$buildtype -module $QUICK_HOME/build/include/$buildtype"
      if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ]; then
        cflags="-L$CUDA_HOME/lib64 -lcuda -lm -lcudart -lcudadevrt -lcublas -lcusolver"
      fi
      ;;
  esac

  fort_flags="$fort_flags -I$QUICK_HOME/src/util -I$QUICK_HOME/build/include/common"
  cc_flags="$opt_flags $cc_debug_flags $lib_flags -I$QUICK_HOME/build/include/$buildtype"
  cxx_flags="$opt_flags $cxx_debug_flags $lib_flags -std=c++11 -I$QUICK_HOME/build/include/$buildtype"

  if [ "$enablef" = 'yes' ]; then
    fort_flags="$fort_flags -DENABLEF"
  fi

  if [ "$buildtype" = 'cuda' ] || [ "$buildtype" = 'cudampi' ]; then

    cpp_flags="$opt_flags -I$CUDA_HOME/include $lib_flags -DCUBLAS_USE_THUNKING"

    cuda_flags="$opt_flags $cuda_debug_flags $cuda_profile_flags $cuda_ext_flags $cuda_arch_flags $cuda_lib_flags -Wno-deprecated-gpu-targets"

    cuda_incl_flags="-L$CUDA_HOME/lib64 -I$CUDA_HOME/include -I$QUICK_HOME/src/cuda/iclass"

    if [ "$enablef" = 'yes' ]; then
      echo "F functions will be compiled in the $buildtype version."
      cuda_incl_flags="$cuda_incl_flags -DGPU_SPDF"
    fi

    # set cew flag for nvcc
    if [ "$aminstall" = "true" ]; then
      cuda_incl_flags="$cuda_incl_flags -I$AMBERHOME/AmberTools/src/cew -DCEW"
    fi

  fi

  # set flags for hip and hipmpi versions
  if [ "$buildtype" = 'hip' ] || [ "$buildtype" = 'hipmpi' ]; then

    fort_flags="$fort_flags -D__HIP_PLATFORM_AMD__ -D__HIP_PLATFORM_HCC__"

    cpp_flags="$opt_flags -I$ROCM_PATH/hip/include $lib_flags"

    hip_flags="$opt_flags $hip_debug_flags $hip_ext_flags $hip_arch_flags $hip_lib_flags"

    hip_incl_flags="-I$ROCM_PATH/hip/include -I$ROCM_PATH/rocblas/include -I$ROCM_PATH/rocsolver/include"

    hip_ld_flags="-L$ROCM_PATH/hip/lib -L$ROCM_PATH/rocblas/lib -L$ROCM_PATH/rocsolver/lib -lrocblas -lrocsolver"

    if [ "$enablef" = 'yes' ]; then
      echo "F functions will be compiled in the $buildtype version."
      hip_incl_flags="$hip_incl_flags -DGPU_SPDF"
    fi

  fi

  # set directives based on the build type. These stuff were previously in config.h

  if [ "$buildtype" = 'mpi' ]; then

    fort_flags="$fort_flags -DMPIV"
    cxx_flags="$cxx_flags -DMPIV"

  elif [ "$buildtype" = 'cuda' ]; then

    fort_flags="$fort_flags -DGPU -DCUDA"
    cc_flags="$cc_flags -DGPU -DCUDA"
    cxx_flags="$cxx_flags -DGPU -DCUDA"
    cuda_incl_flags="$cuda_incl_flags -DGPU -DCUDA"

  elif [ "$buildtype" = 'cudampi' ]; then

    fort_flags="$fort_flags -DMPIV -DMPIV_GPU -DCUDA_MPIV"
    cc_flags="$cc_flags -DMPIV -DMPIV_GPU -DCUDA_MPIV"
    cxx_flags="$cxx_flags -DMPIV -DMPIV_GPU -DCUDA_MPIV"
    cuda_incl_flags="$cuda_incl_flags -DMPIV -DMPIV_GPU -DCUDA_MPIV"

  elif [ "$buildtype" = 'hip' ]; then

    fort_flags="$fort_flags -DGPU -DHIP"
    cc_flags="$cc_flags -DGPU -DHIP"
    cxx_flags="$cxx_flags -DGPU -DHIP"
    hip_incl_flags="$hip_incl_flags -DGPU -DHIP"

  elif [ "$buildtype" = 'hipmpi' ]; then

    fort_flags="$fort_flags -DMPIV -DMPIV_GPU -DHIP_MPIV"
    cc_flags="$cc_flags -DMPIV -DMPIV_GPU -DHIP_MPIV"
    cxx_flags="$cxx_flags -DMPIV -DMPIV_GPU -DHIP_MPIV"
    hip_incl_flags="$hip_incl_flags -DMPIV -DMPIV_GPU -DHIP_MPIV"

  fi

  # set fortran linking flags
  ldflags="$fort_flags -lstdc++"

  # For mpi & cudampi versions, libmpi_cxx.so may be required. This has to be checked and set if required.
  if [ "$buildtype" = 'mpi' -o "$buildtype" = 'cudampi' -o "$buildtype" = 'hipmpi'  ]; then
    set_mpicxx
  fi

  if [ "$buildtype" = 'serial' -o "$buildtype" = 'mpi' ]; then

    # For serial and mpi versions, diagonalizers from lapack/mkl may be used
    if [ "$lapack" = 'yes' ]; then
      check_lapack
      if [ "$?" -eq 0 ]; then
        echo "Matrix diagonalizer from LAPACK will be used for $buildtype version."
        fort_flags="$fort_flags -DLAPACK"
        ldflags="$ldflags -L$BLASROOT/lib -lopenblas"
      fi
    elif [ "$mkl" = 'yes' ]; then
      check_mkl
      if [ "$?" -eq 0 ]; then
        echo "Matrix diagonalizer from MKL will be used for $buildtype version."
        fort_flags="$fort_flags -DMKL"
        ldflags="$ldflags -L$MKLROOT/lib/intel64 -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -liomp5 -lpthread"
      fi
    fi

    # set mirp library flags
    if [ "$mirp" = "yes" ]; then
      fort_flags="$fort_flags -DMIRP"
      cxx_flags="$cxx_flags -I$MIRP_HOME/include -I$MIRP_DEP_HOME/include -DMIRP"
      ldflags="$ldflags -L$MIRP_HOME/lib -L$MIRP_DEP_HOME/lib -larb -lflint -lmirp"
    fi

  fi

  # set amber installation flags
  if [ "$aminstall" = "true" ]; then
      ldflags="$ldflags -L$quick_prefix/lib"
      if [ "$cew" = "yes" ]; then
          fort_flags="$fort_flags -DCEW"

          if [ "$buildtype" = 'mpi' -o "$buildtype" = 'cudampi' ]; then
              ldflags="$ldflags -lcew_mpi"
          else
              ldflags="$ldflags -lcew"
          fi
      fi
  fi
  
  # set dlfind flags
  case "$compiler" in
    gnu)
      fort_ext_lib_flags="$opt_flags $fort_debug_flags -mtune=native -ffree-form -cpp -DGNU $fort_vspec_flags $lib_flags -J$QUICK_HOME/build/include/common"
      ;;
    clang)
      fort_ext_lib_flags="$opt_flags $fort_debug_flags -mtune=native -ffree-form -cpp -DGNU $fort_vspec_flags $lib_flags -J$QUICK_HOME/build/include/common"
      ;;
    intel|pgi|nvidia)
      fort_ext_lib_flags="$opt_flags $fort_debug_flags -mtune=native -ffree-form -cpp -DGNU $fort_vspec_flags $lib_flags -module$QUICK_HOME/build/include/common"
      ;;
  esac

  fort_ext_lib_flags="$fort_ext_lib_flags -I$QUICK_HOME/build/include/$buildtype"

  if [ "$buildtype" = 'mpi' ]; then
    fort_ext_lib_flags="$fort_ext_lib_flags -DMPIV"
  elif [ "$buildtype" = 'cuda' ]; then
    fort_ext_lib_flags="$fort_ext_lib_flags -DGPU -DCUDA"
  elif [ "$buildtype" = 'cudampi' ]; then
    fort_ext_lib_flags="$fort_ext_lib_flags -DMPIV -DMPIV_GPU -DCUDA_MPIV"
  elif [ "$buildtype" = 'hip' ]; then
    fort_ext_lib_flags="$fort_ext_lib_flags -DGPU -DHIP"
  elif [ "$buildtype" = 'hipmpi' ]; then
    fort_ext_lib_flags="$fort_ext_lib_flags -DMPIV -DMPIV_GPU -DHIP_MPIV"
  fi

  # set the installer
  installer=''
  if [ "$buildtype" = 'serial' ]; then
    installer='quick'
  elif [ "$buildtype" = 'mpi' ]; then
    installer='quick.MPI'
  elif [ "$buildtype" = 'cuda' ]; then
    installer='quick.cuda'
  elif [ "$buildtype" = 'cudampi' ]; then
    installer='quick.cuda.MPI'
  elif [ "$buildtype" = 'hip' ]; then
    installer='quick.hip'
  elif [ "$buildtype" = 'hipmpi' ]; then
    installer='quick.hip.MPI'
  fi

  # set the test type
  if [ "$useprefix" = "true" ] && [ "$aminstall" = "false" ]; then
    testtype='installtest'
  fi

  # set libxcobj and blasobj folder
  if [ "$buildtype" = 'serial' -o "$buildtype" = 'mpi' ]; then
    libxcobjfolder="$QUICK_HOME/build/common/cpu/libxcobj"
    libxcdevobjfolder=""
  elif [ "$buildtype" = 'cuda' -o "$buildtype" = 'cudampi' ]; then
    libxcobjfolder="$QUICK_HOME/build/common/gpu/libxcobj"
    libxcdevobjfolder="$QUICK_HOME/build/common/gpu/libxcdevobj"
  elif [ "$buildtype" = 'hip' -o "$buildtype" = 'hipmpi' ]; then
    blasobjfolder="$QUICK_HOME/build/common/cpu/blasobj"
    libxcobjfolder="$QUICK_HOME/build/common/gpu/libxcobj"
    libxcdevobjfolder="$QUICK_HOME/build/common/gpu/libxcdevobj"
  fi
 
  # set blasobj folder
  blasobjfolder="$QUICK_HOME/build/common/cpu/blasobj"
 
  # set dlfindobj folder
  dlfindobjfolder="$QUICK_HOME/build/common/cpu/dlfindobj"

  # set lapack folder
  lapackobjfolder="$QUICK_HOME/build/common/cpu/lapackobj"

  #set dftd3obj folder
  dftd3objfolder="$QUICK_HOME/build/common/cpu/dftd3obj"

  # copy template Makefile into each buildtype directory
  cp -f "$QUICK_HOME/tools/build-makefile" "$QUICK_HOME/build/Makefile"

  # write make.in for each build type

cat > "$QUICK_HOME/build/make.$buildtype.in" << EOF

# $QUICK_VERSION configuration file
# Created on $cdate at $ctime

#!---------------------------------------------------------------------!
#! Build settings                                                      !
#!---------------------------------------------------------------------!

BUILDTYPE=$buildtype
installer=$installer

# number of cores for the compilation
ncores=$ncores

# control build output
VB=$verbose

#!---------------------------------------------------------------------!
#! Directories                                                         !
#!---------------------------------------------------------------------!

# source directories
srcfolder=$QUICK_HOME/src
subfolder=$QUICK_HOME/src/subs
blasfolder=$QUICK_HOME/src/blas
lapackfolder=$QUICK_HOME/src/lapack
libxcfolder=$QUICK_HOME/src/libxc
dlfindfolder=$QUICK_HOME/src/dlfind
dftd3folder=$QUICK_HOME/src/dftd3
cudafolder=$QUICK_HOME/src/cuda
cublasfolder=$QUICK_HOME/src/cuda/cublas
cusolverfolder=$QUICK_HOME/src/cuda/cusolver
hipfolder=$QUICK_HOME/src/hip
rocblasfolder=$QUICK_HOME/src/hip/rocblas
rocsolverfolder=$QUICK_HOME/src/hip/rocsolver
octfolder=$QUICK_HOME/src/octree
modfolder=$QUICK_HOME/src/modules

# build directories
exefolder=$QUICK_HOME/bin
objfolder=$QUICK_HOME/build/obj/$buildtype
libxcobjfolder=$libxcobjfolder
libxcdevobjfolder=$libxcdevobjfolder
dlfindobjfolder=$dlfindobjfolder
dftd3objfolder=$dftd3objfolder
mainobjfolder=$QUICK_HOME/build/obj/$buildtype/main
blasobjfolder=$blasobjfolder
lapackobjfolder=$lapackobjfolder
libfolder=$QUICK_HOME/build/lib/$buildtype
inclfolder=$QUICK_HOME/build/include/$buildtype

# install directories
installfolder=$quick_prefix

#!---------------------------------------------------------------------!
#! Compilers                                                           !
#!---------------------------------------------------------------------!

FC=$fort
CC=$cc
CXX=$cxx
CUDAC=$nvcc
HIPCC=$hipcc

#!---------------------------------------------------------------------!
#! Archiver and flags for the libraries                                !
#!---------------------------------------------------------------------!

ARCH=$arch
ARCHFLAGS=$arch_flags
RANLIB=$ranlib
LIBEXT=$libext
BLAS_FLAGS=$blas_opt_flags $lib_flags
LAPACK_FLAGS=$blas_opt_flags $lib_flags
FORT_EXT_LIB_FLAGS=$fort_ext_lib_flags

#!---------------------------------------------------------------------!
#! Common compiler  flags                                              !
#!---------------------------------------------------------------------!

FFLAGS=$fort_flags
LDFLAGS=$ldflags
CCFLAGS=$cc_flags
CXXFLAGS=$cxx_flags

EOF

if [ "$buildtype" = 'cuda' ] || [ "$buildtype" = 'cudampi' ]; then
cat >> "$QUICK_HOME/build/make.$buildtype.in" << EOF
#!---------------------------------------------------------------------!
#! CUDA specific flags                                                 !
#!---------------------------------------------------------------------!

CPP_FLAG=$cpp_flags
CUDA_FLAGS=$cuda_flags
CUDA_INCL_FLAGS=$cuda_incl_flags
CUDA_DC_FLAGS=$cuda_dc_flags
CFLAGS=$cflags

EOF
fi

if [ "$buildtype" = 'hip' ] || [ "$buildtype" = 'hipmpi' ]; then
cat >> "$QUICK_HOME/build/make.$buildtype.in" << EOF
#!---------------------------------------------------------------------!
#! HIP specific flags                                                  !
#!---------------------------------------------------------------------!

ROCM_PATH=$ROCM_PATH
ROCBLAS_PATH=$ROCM_PATH/rocblas
CPP_FLAG=$cpp_flags
HIP_FLAGS=$hip_flags
HIP_INCL_FLAGS=$hip_incl_flags
HIP_DC_FLAGS=$hip_dc_flags
HIP_LD_FLAGS=$hip_ld_flags
HIP_MPI_LD_FLAGS=$hip_mpi_flags
CFLAGS=$cflags

EOF
fi

done

#  !---------------------------------------------------------------------!
#  ! Generate config.h in src directory                                  !
#  !---------------------------------------------------------------------!
cat > "$QUICK_HOME/make.in" << EOF

# $QUICK_VERSION configuration file
# Created on $cdate at $ctime

#!---------------------------------------------------------------------!
#! Build & install settings                                            !
#!---------------------------------------------------------------------!

BUILDTYPES=$buildtypes
CLEANTYPES=$cleantypes
SHARED=$shared

INSTALLTYPES=$installtypes
UNINSTALLTYPES=$uninstalltypes

TESTTYPE=$testtype

#!---------------------------------------------------------------------!
#! Directories                                                         !
#!---------------------------------------------------------------------!

homefolder=$QUICK_HOME
exefolder=$QUICK_HOME/bin
buildfolder=$QUICK_HOME/build
toolsfolder=$QUICK_HOME/tools
installfolder=$quick_prefix

# source directories
subfolder=$QUICK_HOME/src/subs
blasfolder=$QUICK_HOME/src/blas
lapackfolder=$QUICK_HOME/src/lapack
libxcfolder=$QUICK_HOME/src/libxc
dlfindfolder=$QUICK_HOME/src/dlfind
dftd3folder=$QUICK_HOME/src/dftd3
cudafolder=$QUICK_HOME/src/cuda
hipfolder=$QUICK_HOME/src/hip
octfolder=$QUICK_HOME/src/octree
modfolder=$QUICK_HOME/src/modules

EOF

#  !---------------------------------------------------------------------!
#  ! Generate quick.rc in install directory                              !
#  !---------------------------------------------------------------------!
cat > "$quick_prefix/quick.rc" << EOF
export QUICK_INSTALL=$quick_prefix
export QUICK_BASIS=\$QUICK_INSTALL/basis
export PATH=\$QUICK_INSTALL/bin:\$PATH
EOF

if [ "$shared" = 'yes' ]; then
libpaths=''
libpath=''

if [ "$testtype" = 'installtest' ]; then
  libpath="\$QUICK_INSTALL/lib"
else
  libpath="\$QUICK_INSTALL/build/lib"
fi

if [ "$aminstall" = "true" ]; then
  libpaths="\$QUICK_INSTALL/lib:"
else
  for buildtype in $buildtypes; do
    libpaths="$libpath/$buildtype:$libpaths"
  done
fi

if [ "$buildtype" = 'serial' -o "$buildtype" = 'mpi' ]; then
  if [ "$mirp" = "yes" ]; then
    libpaths="$MIRP_HOME/lib:$MIRP_DEP_HOME/lib:$libpaths"
  fi
fi

cat >> "$quick_prefix/quick.rc" << EOF
export LD_LIBRARY_PATH=$libpaths\$LD_LIBRARY_PATH
EOF
fi

#  !---------------------------------------------------------------------!
#  ! Clean directories                                                   !
#  !---------------------------------------------------------------------!

#make clean > /dev/null

echo  "Input file for GNU make was successfully created."
echo ""

echo  "Next steps:"
echo  "          Run 'make' to build QUICK."

if [ "$aminstall" = "true" ]; then
  echo  "          Run 'make install' to install QUICK executables and libraries into AMBER home directory $quick_prefix."
elif [ "$testtype" = 'installtest' ]; then
  echo  "          Run 'make install' to install executable/s, libraries and header files in $quick_prefix."
fi

if [ "$aminstall" = "false" ]; then
  echo  "          Run 'make test' to verify the executables."
fi

