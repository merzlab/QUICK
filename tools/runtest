#!/bin/sh

#  !---------------------------------------------------------------------!
#  ! Written by Madu Manathunga on 07/19/2020                            !
#  !                                                                     !
#  ! Copyright (C) 2020-2021 Merz lab                                    !
#  ! Copyright (C) 2020-2021 GÃ¶tz lab                                    !
#  !                                                                     !
#  ! This Source Code Form is subject to the terms of the Mozilla Public !
#  ! License, v. 2.0. If a copy of the MPL was not distributed with this !
#  ! file, You can obtain one at http://mozilla.org/MPL/2.0/.            !
#  !_____________________________________________________________________!
#
#  !---------------------------------------------------------------------!
#  ! This source code runs a series test cases saved in test folder and  !
#  ! verifies the correctness of a QUICK installation.                   !
#  ! ** Must be executed from QUICK_HOME or installation directories.    !
#  !---------------------------------------------------------------------!

#  !---------------------------------------------------------------------!
#  ! QUICK version and time                                              !
#  !---------------------------------------------------------------------!

QUICK_VERSION='QUICK-20.06'
cdate=`date +'%m/%d/%Y'`
ctime=`date +'%r'`

#  !---------------------------------------------------------------------!
#  ! Variable definitions                                                !
#  !---------------------------------------------------------------------!

# directories
installdir=`pwd`
testdir="$installdir/test"
qbasisdir="$installdir/basis"
qbindir="$installdir/bin"

# executables

qexe=''
buildtypes=''
serial='no'
mpi='no'
cuda='no'
cudampi='no'

# number of cores for mpi tests
nprocs=2

# flag for a mp2 calculation
ismp2=''

#  !---------------------------------------------------------------------!
#  ! Function definitions                                                !
#  !---------------------------------------------------------------------!

print_test_info(){

  ismp2='no'

  case "$i" in
    ene_psb5_rhf_631g)        echo "RHF energy test: s and p basis functions";;
    ene_psb5_rhf_631gss)      echo "RHF energy test: s, p and d basis functions";;
    ene_psb3_blyp_631g)       echo "DFT energy test: s and p basis functions, native BLYP functional";;
    ene_psb3_blyp_631gss)     echo "DFT energy test: s, p and d basis functions, native BLYP functional";;
    ene_psb3_b3lyp_631g)      echo "DFT energy test: s and p basis functions, native B3LYP functional";;
    ene_psb3_b3lyp_631gss)    echo "DFT energy test: s, p and d basis functions, native B3LYP functional";;
    ene_psb3_libxc_lda_631g)  echo "DFT energy test: s and p basis functions, libxc LDA functional";;
    ene_psb3_libxc_gga_631g)  echo "DFT energy test: s and p basis functions, libxc GGA functional";;
    ene_psb3_libxc_hgga_631g) echo "DFT energy test: s and p basis functions, libxc hybrid GGA functional";;
    ene_wat2_mp2_631g)        echo "MP2 energy test: s and p basis functions"; ismp2='yes';;
    ene_wat2_mp2_631gss)      echo "MP2 energy test: s, p and d basis functions"; ismp2='yes';;
    opt_wat_rhf_631g)         echo "RHF geometry optimization test: s and p basis functions";;
    opt_wat_rhf_ccpvdz)       echo "RHF geometry optimization test: s, p and d basis functions";;
  esac

}


#  !---------------------------------------------------------------------!
#  ! Check directories & executables                                     !
#  !---------------------------------------------------------------------!

if [ ! -d "$qbindir" ]; then
  echo -e "\033[91mError: QUICK bin folder not found. \033[0m"
  exit 1
fi

if [ ! -d "$qbasisdir" ]; then
  echo -e "\033[91mError: QUICK basis folder not found. \033[0m"
  exit 1
else
  export QUICK_BASIS=$qbasisdir
fi

if [ ! -d "$testdir" ]; then
  echo -e "\033[91mError: QUICK test folder not found. \033[0m"
  exit 1
fi

# check for executables
if [ -x "$qbindir/quick.cuda.mpi" ]; then
  serial='cudampi'
  buildtypes="$buildtypes cudampi"
fi

if [ -x "$qbindir/quick.cuda" ]; then
  cuda='yes'
  buildtypes="$buildtypes cuda"
fi

if [ -x "$qbindir/quick.mpi" ]; then
  mpi='yes'
  buildtypes="$buildtypes mpi"
fi

if [ -x "$qbindir/quick" ]; then
  serial='yes'
  buildtypes="$buildtypes serial"
fi

if [ -z "${buildtypes// }" ]; then
  echo -e "\033[91mError: No QUICK executables found in $qbindir. \033[0m"
  exit 1
fi

if [ ! -f "$testdir/testlist.txt" ]; then
  echo -e "\033[91mError: testlist.txt not found in $testdir. \033[0m"
  exit 1
fi

# check for mpirun 
if [ "$mpi" = 'yes' -o "$cudampi" = 'yes' ]; then
  echo "MPI tests will be carried out using a single core."
  echo ""
fi

#  !---------------------------------------------------------------------!
#  ! Create required directories                                         !
#  !---------------------------------------------------------------------!

if [ -d "$testdir/runs" ]; then
  rm -rf "$testdir/runs/"*
else
  mkdir -p "$testdir/runs"
fi

for buildtype in $buildtypes; do
  mkdir -p "$testdir/runs/$buildtype"
done

#  !---------------------------------------------------------------------!
#  ! Run tests                                                           !
#  !---------------------------------------------------------------------!

cd "$testdir"

for buildtype in $buildtypes; do

  echo -e "\033[92mTesting $buildtype version..\033[0m"

  # set qexe
  if [ "$buildtype" = 'serial' ]; then
    qexe='quick'
  elif [ "$buildtype" = 'mpi' ]; then
    qexe='quick.mpi'
  elif [ "$buildtype" = 'cuda' ]; then
    qexe='quick.cuda'
  elif [ "$buildtype" = 'cudampi' ]; then
    qexe='quick.cuda.mpi'
  fi


  total=`cat "$testdir/testlist.txt" |wc -l`
  a=1
  cd "$testdir/runs/$buildtype"

  # Run energy tests
  for i in `awk '{print $1}' "$testdir/testlist.txt"| grep "ene"`; do
    echo "Running test $a of $total"
    cp "$testdir/$i.in" ./
	
    # This variable will keep the information of jobcard
    jobcard=`head -1 "$i.in"`
    enecalc=`echo $jobcard | grep 'ENERGY' |wc -l` 

    print_test_info "$i"

    # Run the test case
    "$qbindir/$qexe" "${i}.in"  2> /dev/null > /dev/null	

    # Check the accuracy
    # For RHF and DFT,  just compare the total energy. For MP2 compare the mp2 energy. 
    if [ "$enecalc" -gt 0 -a "$ismp2" = 'yes' ]; then

      refval=`grep "#MP2_ENERGY" "$i.in" |awk '{print $2}'`
      newval=`grep -A 20 "REACH CONVERGENCE AFTER" ${i}.out| grep "EMP2" | awk '{print $3}'`
      echo "$refval  $newval"|awk '{
        x=sqrt(($1-$2)^2); 
        if(x>=0.00001) stat="\033[1;31mFailed\033[0m"; else stat="\033[1;32mPassed\033[0m"; 
        print "MP2 energy: " $2 ", Reference value: " $1 ". " stat""
      }'                         

    else 

      refval=`grep "#TOTAL_ENERGY" "$i.in" | awk '{print $2}'`
      newval=`grep -A 8 "REACH CONVERGENCE AFTER" "$i.out" | grep "TOTAL" | awk '{print $4}'`
      echo "$refval  $newval"|awk '{
        x=sqrt(($1-$2)^2); 
        if(x>=0.00001) stat="\033[1;31mFailed\033[0m"; else stat="\033[1;32mPassed\033[0m"; 
        print "Total energy: " $2 ", Reference value: " $1 ". " stat""
      }'	

    fi

    echo ""
    a=$((a+1))
  done



  # Run gradient tests
  for i in `awk '{print $1}' "$testdir/testlist.txt" |grep "grad"`; do
    echo "Running test $a of $total"
    cp "$testdir/$i.in" ./

    #This variable will keep the information of jobcard
    jobcard=`head -1 "$i.in"`
    gradcalc=`echo $jobcard | grep 'GRADIENT' | wc -l`

    print_test_info "$i"

    "$qbindir/$qexe" "$i.in" 2> /dev/null > /dev/null
		
	#Check the accuracy of gradients of first step
	grep "#ref_grad" "$i.in" |awk '{print $2}'>refGrad.txt

    echo ""
    a=$((a+1))	
  done


  # Run geometry optimization tests
  for i in `awk '{print $1}' "$testdir/testlist.txt" | grep "opt"`; do
    echo "Running test $a of $total"
    cp "$testdir/${i}.in" ./

    print_test_info "$i"

    # Run the test case
    "$qbindir/$qexe" "$i.in" 2> /dev/null > /dev/null

    # Check the accuracy of gradients of first step
    grep "#ref_grad" "$i.in" | awk '{print $2}'>refGrad.txt
    sed -n '/GEOMETRY FOR OPTIMIZATION STEP   1/,/GEOMETRY FOR OPTIMIZATION STEP   2/p' "$i.out" | sed -n '/NEW_GRAD/,/OPTIMZATION STATISTICS/p' |grep '[0-9]' |awk '{print $4}'>newGrad.txt
    paste refGrad.txt newGrad.txt >compGrad.txt
    awk '{
      x=sqrt(($1-$2)^2); 
      if(x>=0.00001) stat="\033[1;31mFailed\033[0m"; else stat="\033[1;32mPassed\033[0m"; 
      print "Final gradient: " $2 ", Reference value: " $1 ". " stat""
      }' compGrad.txt
    echo ""
      
    # remove gradient info files
    rm refGrad.txt newGrad.txt compGrad.txt
      
    # Check the minimum energy
    refval=$(grep "#ref_min_ene" "$i.in" | awk '{print $2}')
    newval=$(grep "MINIMIZED ENERGY" "$i.out" | awk '{print $3}')
    echo "$refval  $newval"|awk '{
      x=sqrt(($1-$2)^2); 
      if(x>=0.00001) stat="\033[1;31mFailed\033[0m"; else stat="\033[1;32mPassed\033[0m"; 
      print "Minimized energy: " $2 ", Reference value: " $1 ". " stat""
      }'
    echo ""

    a=$((a+1))		

  done
	
  echo "$buildtype tests are done!"
  echo ""
  cd "$testdir"
done

echo -e "\033[92mAll tests are done! \033[0m"

cd $installdir

exit 0


