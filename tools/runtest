#!/bin/bash

#  !---------------------------------------------------------------------!
#  ! Written by Madu Manathunga on 07/19/2020                            !
#  !                                                                     !
#  ! Copyright (C) 2020-2021 Merz lab                                    !
#  ! Copyright (C) 2020-2021 GÃ¶tz lab                                    !
#  !                                                                     !
#  ! This Source Code Form is subject to the terms of the Mozilla Public !
#  ! License, v. 2.0. If a copy of the MPL was not distributed with this !
#  ! file, You can obtain one at http://mozilla.org/MPL/2.0/.            !
#  !_____________________________________________________________________!
#
#  !---------------------------------------------------------------------!
#  ! This source code runs a series test cases saved in test folder and  !
#  ! verifies the correctness of a QUICK installation.                   !
#  ! ** Must be executed from QUICK_HOME or installation directories.    !
#  !---------------------------------------------------------------------!

#  !---------------------------------------------------------------------!
#  ! QUICK version                                                       !
#  !---------------------------------------------------------------------!
QUICK_VERSION='QUICK-25.03'

#  !---------------------------------------------------------------------!
#  ! Variable definitions                                                !
#  !---------------------------------------------------------------------!
# directories
installdir=`pwd`
testdir="$installdir/test"
qbasisdir="$installdir/basis"
qbindir="$installdir/bin"
export QUICK_HOME="$installdir"

# executables
qexe=''
buildtypes=''
serial='no'
mpi='no'
cuda='no'
cudampi='no'
hip='no'
hipmpi='no'
apiexe=''

# test list file
test_list=''

# flag to indicate if mpirun is available
ismpirun='no'

# flag to indicate if GNU parallel is available
has_parallel='no'

# test types to run
test_ene='no'
test_grad='no'
test_opt='no'
test_api='no'
test_rw='no'
test_esp='no'
uspec_test='no'
test_length='short'

# verbosity
log='yes'

# variable to keep track of total failed tests
ncum_failed_tests=0

# path to api executables
apipath=''


#  !---------------------------------------------------------------------!
#  ! Function definitions                                                !
#  !---------------------------------------------------------------------!
# This function checks if required dependencies for this script
# exist and are executable.
#
# arguments: required dependencies to check for.
check_for_req_deps()
{
  for prog in $@; do
    fullpath=`which $prog`
    if [ ! -x "$fullpath" ]; then
      if [ ! -f "$fullpath" ]; then
        echo "Error: $prog not found. Install this program to run this test script."
      else
        echo "Error: $prog found but not executable. Install this program to run this test script."
      fi
      exit 1;
    fi
  done
}


# this function prints help page
print_help()
{
  echo  "                                                                                                                                       
  Use this script as ./runtest [flags]                            
                                                                            
  Available flags are:                                                      
      --serial              Tests QUICK serial version                                
      --mpi                 Tests QUICK MPI parallel version                           
      --cuda                Tests QUICK GPU version
      --cudampi             Tests QUICK multi-GPU version
      --hip                 Tests QUICK AMD GPU version
      --hipmpi              Tests QUICK AMD multi-GPU version
      --ene                 Run only energy tests
      --grad                Run only gradient tests
      --opt                 Run only geometry optimization tests
      --api                 Run only api tests
      --rw                  Run only restart tests
      --esp                 Run only ESP tests
      --full                Run a large set of tests (Default: no)
      --nolog               Disable writing output into runtest.log/runtest-verbose.log (Default: no)
                                                                            
  If the version flags are not specified, the script will try to detect
  the executables and test them.

  Environment variables which influence this script:
      DO_PARALLEL           Command for launching MPI/MPI+X versions
                            Example: DO_PARALLEL=\"mpirun -np 2\"
      CUDA_VISIBLE_DEVICES  Comma-seperated list of GPU IDs to use
                            for GPU versions (CUDA/HIP)
                            Example: CUDA_VISIBLE_DEVICES=\"0,1\"
      HIP_VISIBLE_DEVICES   Comma-seperated list of GPU IDs to use
                            for GPU versions (HIP)
                            Example: HIP_VISIBLE_DEVICES=\"2,3\"
      PARALLEL_TEST_COUNT   Number of tests to run in parallel using GNU parallel;
                            can be combined with the above 3 variables
			    for parallel testing with applicable QUICK versions
                            Example: PARALLEL_TEST_COUNT=\"2\"

  "

  exit 0;
}


# this function creates an exclusive lock on an existing file for writing
# using atomic operations
#
# arguments:
#   $1: file to lock
lock_file()
{
  if [ $has_parallel = 'yes' ]; then
    while ! ln -s "${1}" "${1}.lock" > /dev/null 2>&1; do
      sleep 0.01;
    done
  fi
}


# This function removes an existing exclusive lock file for writing
# using atomic operations.
#
# arguments:
#   $1: file with established lock file to unlock
unlock_file()
{
  if [ $has_parallel = 'yes' ]; then
    mv "${1}.lock" "${1}.deleteme" && rm -f "${1}.deleteme"
  fi
}


# function to set correct quick executable and test list
# must be called from a loop where $buildtype carries build type
#
# arguments:
#   $1: QUICK version (a.k.a. build type) which to configure tests for
# outputs:
#   qexe: name of QUICK executable to use for running non-API tests
#   apiexe: name of QUICK executable to use for running API tests
#   apipath: directory containing QUICK executable for running API tests
#   test_list: filename containing test list to execute
set_qexe_testlist()
{
  if [ "$1" = 'serial' ]; then
    qexe='quick'
    apiexe='test-api'

    if [ -x "$testdir/test-api" ]; then
      apipath=$testdir
    elif [ -x "$qbindir/test-api" ]; then
      apipath=$qbindir
    fi

    if [ "$test_length" = 'full' ]; then
      test_list="$testdir/testlist_full.txt"
    else
      test_list="$testdir/testlist_short.txt"
    fi
  elif [ "$1" = 'mpi' ]; then
    qexe='quick.MPI'
    apiexe='test-api.MPI'

    if [ -x "$testdir/test-api.MPI" ]; then
      apipath=$testdir
    elif [ -x "$qbindir/test-api.MPI" ]; then
      apipath=$qbindir
    fi

    if [ "$test_length" = 'full' ]; then
      test_list="$testdir/testlist_full.txt"
    else
      test_list="$testdir/testlist_short.txt"
    fi
  elif [ "$1" = 'cuda' ]; then
    qexe='quick.cuda'
    apiexe='test-api.cuda'

    if [ -x "$testdir/test-api.cuda" ]; then
      apipath=$testdir
    elif [ -x "$qbindir/test-api.cuda" ]; then
      apipath=$qbindir
    fi

    if [ "$test_length" = 'full' ]; then
      test_list="$testdir/testlist_full_gpu.txt"
    else
      test_list="$testdir/testlist_short_gpu.txt"
    fi
  elif [ "$1" = 'cudampi' ]; then
    qexe='quick.cuda.MPI'
    apiexe='test-api.cuda.MPI'

    if [ -x "$testdir/test-api.cuda.MPI" ]; then
      apipath=$testdir
    elif [ -x "$qbindir/test-api.cuda.MPI" ]; then
      apipath=$qbindir
    fi

    if [ "$test_length" = 'full' ]; then
      test_list="$testdir/testlist_full_gpu.txt"
    else
      test_list="$testdir/testlist_short_gpu.txt"
    fi
  elif [ "$1" = 'hip' ]; then
    qexe='quick.hip'
    apiexe='test-api.hip'

    if [ -x "$testdir/test-api.hip" ]; then
      apipath=$testdir
    elif [ -x "$qbindir/test-api.hip" ]; then
      apipath=$qbindir
    fi

    if [ "$test_length" = 'full' ]; then
      test_list="$testdir/testlist_full_gpu.txt"
    else
      test_list="$testdir/testlist_short_gpu.txt"
    fi
  elif [ "$1" = 'hipmpi' ]; then
    qexe='quick.hip.MPI'
    apiexe='test-api.hip.MPI'

    if [ -x "$testdir/test-api.hip.MPI" ]; then
      apipath=$testdir
    elif [ -x "$qbindir/test-api.hip.MPI" ]; then
      apipath=$qbindir
    fi

    if [ "$test_length" = 'full' ]; then
      test_list="$testdir/testlist_full_gpu.txt"
    else
      test_list="$testdir/testlist_short_gpu.txt"
    fi
  fi
}


# function to set the GPUs assigned to GNU parallel jobs
#
# arguments:
#   $1: available GPU IDs (0-based indexing) (i.e., {CUDA,HIP}_VISIBLE_DEVICES)
# outputs:
#   total_gpus: total number of GPUs
#   gpus_per_job: number of GPUs per job
#   job_gpus: array of GPU IDs assigned to each job (0-based indexing)
set_job_gpus()
{
  total_gpus=`echo "$1" | awk -F ',' '{print NF}'`
  gpus_per_job=$(($total_gpus/$PARALLEL_TEST_COUNT))

  if [ "$total_gpus" -lt "$PARALLEL_TEST_COUNT" ]; then
    echo "Error: invalid # GPUs detected in HIP_VISIBLE_DEVICES/CUDA_VISIBLE_DEVICES (# GPUs <= PARALLEL_TEST_COUNT)."
    exit 1;
  fi

  job_gpus=()
  for i in `seq 0 $(($PARALLEL_TEST_COUNT-1))`;
  do
    job_gpus[$i]="`echo $1 | cut -f $(($i*$gpus_per_job+1))-$((($i+1)*$gpus_per_job)) -d ','`"
  done
}


# function to set the various test lists and counts
#
# arguments:
#   $1: run energy tests ['yes'|'no']
#   $2: run gradient tests ['yes'|'no']
#   $3: run geometry optimization tests ['yes'|'no']
#   $4: run API tests ['yes'|'no']
#   $5: run restart tests ['yes'|'no']
#   $6: run ESP tests ['yes'|'no']
#
# outputs:
#   tests: array of tests
#   test_names: array of test names
#   tot_{ene,grad,opt,api,esp}_tests: counts for test lists by type
#   total_tests: sum of counts for all test types
get_total_tests()
{
  tests=()
  test_names=()
  tot_ene_tests=0 
  tot_grad_tests=0 
  tot_opt_tests=0 
  tot_api_tests=0 
  tot_rw_tests=0 
  tot_esp_tests=0 
  total_tests=0 

  if [ "$1" = 'yes' ]; then
    tot_ene_tests="${#tests[@]}"
    tests+=(`grep "^ene_" "$test_list" | awk '{print $1}'`)
    while IFS= read -r line; do
        test_names+=("$line")
    done < <(grep "^ene_" "$test_list" | awk 'BEGIN { FPAT="([^#]+)"; OFS="\n"; } {print $2}')
    total_tests="${#tests[@]}"
    tot_ene_tests=$(($total_tests-$tot_ene_tests))
  fi

  if [ "$2" = 'yes' ]; then
    tot_grad_tests="${#tests[@]}"
    tests+=(`grep "^grad_" "$test_list" | awk '{print $1}'`)
    while IFS= read -r line; do
        test_names+=("$line")
    done < <(grep "^grad_" "$test_list" | awk 'BEGIN { FPAT="([^#]+)"; OFS="\n"; } {print $2}')
    total_tests="${#tests[@]}"
    tot_grad_tests=$(($total_tests-$tot_grad_tests))
  fi

  if [ "$3" = 'yes' ]; then
    tot_opt_tests="${#tests[@]}"
    tests+=(`grep "^opt_" "$test_list" | awk '{print $1}'`)
    while IFS= read -r line; do
        test_names+=("$line")
    done < <(grep "^opt_" "$test_list" | awk 'BEGIN { FPAT="([^#]+)"; OFS="\n"; } {print $2}')
    total_tests="${#tests[@]}"
    tot_opt_tests=$(($total_tests-$tot_opt_tests))
  fi

  if [ "$4" = 'yes' ]; then
    tot_api_tests="${#tests[@]}"
    tests+=(`grep "^api_" "$test_list" | awk '{print $1}'`)
    while IFS= read -r line; do
        test_names+=("$line")
    done < <(grep "^api_" "$test_list" | awk 'BEGIN { FPAT="([^#]+)"; OFS="\n"; } {print $2}')
    total_tests="${#tests[@]}"
    tot_api_tests=$(($total_tests-$tot_api_tests))
  fi

  if [ "$5" = 'yes' ]; then
    tot_rw_tests="${#tests[@]}"
    tests+=(`grep "^rw_" "$test_list" | awk '{print $1}'`)
    while IFS= read -r line; do
        test_names+=("$line")
    done < <(grep "^rw_" "$test_list" | awk 'BEGIN { FPAT="([^#]+)"; OFS="\n"; } {print $2}')
    total_tests="${#tests[@]}"
    tot_rw_tests=$(($total_tests-$tot_rw_tests))
  fi

  if [ "$6" = 'yes' ]; then
    tot_esp_tests="${#tests[@]}"
    tests+=(`grep "^esp_" "$test_list" | awk '{print $1}'`)
    while IFS= read -r line; do
        test_names+=("$line")
    done < <(grep "^esp_" "$test_list" | awk 'BEGIN { FPAT="([^#]+)"; OFS="\n"; } {print $2}')
    total_tests="${#tests[@]}"
    tot_esp_tests=$(($total_tests-$tot_esp_tests))
  fi
}


# function to set files for a test run
#
# arguments:
#   $1: test name
#   $2: test directory
#   $3: job slot (GNU parallel) (1-based indexing)
set_test()
{
  if [ $has_parallel = 'yes' ]; then
    if [ "$hip" = 'yes' -o "$hipmpi" = 'yes' ]; then
      if [ -n "$HIP_VISIBLE_DEVICES" ]; then
        set_job_gpus "$HIP_VISIBLE_DEVICES"
        export HIP_VISIBLE_DEVICES="${job_gpus[$(($3-1))]}"
        export CUDA_VISIBLE_DEVICES=""
      fi
    elif [ "$cuda" = 'yes' -o "$cudampi" = 'yes' ]; then
      if [ -n "$CUDA_VISIBLE_DEVICES" ]; then
        set_job_gpus "$CUDA_VISIBLE_DEVICES"
        export HIP_VISIBLE_DEVICES=""
        export CUDA_VISIBLE_DEVICES="${job_gpus[$(($3-1))]}"
      fi
    fi
  fi

  # copy input if the test is not an api test
  if [ `echo "$1" | grep '^api_' | wc -l` -lt 1 ]; then
    cp "$2/$1.in" ./
  fi

  if [ `echo "$1" | grep '^rw_' | wc -l` -eq 1 ]; then
    cp "$2/$1_read.in" ./
  else
    cp "$2/saved/$1.out" "$1.ref.out"
  fi

  # copy extra files generated while computing ESP on grid points
  if [ `echo "$1" | grep '^esp_grid_'| wc -l` -gt 0 ]; then
    cp "$2/saved/$1.esp" "$1.ref.esp"
  elif [ `echo "$1" | grep '^esp_'| wc -l` -gt 0 ]; then
    cp "$2/saved/$1.vdw" "$1.ref.vdw"
  fi
}


# function to run tests.
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number
#   $4: total number of tests
#   $5: test summary log file
#   $6: test verbose log file (captures stdout/stderr from running QUICK executables)
run_test()
{
  # Run the test case
  rm -f "$1.tmp" "$1_read.tmp"
  if [ $buildtype = 'mpi' ] || [ $buildtype = 'cudampi' ] || [ $buildtype = 'hipmpi' ] && [ $ismpirun = 'yes' ]; then
    eval "$DO_PARALLEL $qbindir/$qexe $1.in" >"$1.tmp" 2>&1
    if [ `echo "$1" | grep '^rw_' | wc -l` -eq 1 ]; then
      eval "$DO_PARALLEL $qbindir/$qexe $1_read.in" >"$1_read.tmp" 2>&1
    fi
  else
    "$qbindir/$qexe" "$1.in" >"$1.tmp" 2>&1
    if [ `echo "$1" | grep '^rw_' | wc -l` -eq 1 ]; then
      "$qbindir/$qexe" "$1_read.in" >"$1_read.tmp" 2>&1
    fi
  fi
  qexe_ret="$?"

  lock_file "$6"
  echo "Test $3 of $4" >> "$6"
  echo "$2" >> "$6"
  echo "QUICK executable output (stdout/stderr):" >> "$6"
  cat "$1.tmp" >> "$6"
  if [ `echo "$1" | grep '^rw_' | wc -l` -eq 1 ]; then
    cat "$1_read.tmp" >> "$6"
  fi
  rm -f "$1.tmp" "$1_read.tmp"
  echo >> "$6"
  echo >> "$6"
  unlock_file "$6"

  check_f_error $1
  check_f_error_ret="$?"
  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  if [ "$qexe_ret" -ne 0 ] && [ "$check_f_error_ret" -eq 0 ] && [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    echo "Error: $qexe execution failed."
    echo ""
  
    # on failure, log header of failing test
    lock_file "$5"
    echo "Running test $3 of $4" | tee -a "$5"
    echo "$2" | tee -a "$5"
    unlock_file "$5"
  
    exit 1
  fi
}


# function to run api tests
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number
#   $4: total number of tests
#   $5: test summary log file
#   $6: test verbose log file (captures stdout/stderr from running QUICK executables)
run_test_api()
{
  #Run test
  rm -f "$1.tmp"
  if [ $buildtype = 'mpi' ] || [ $buildtype = 'cudampi' ] || [ $buildtype = 'hipmpi' ] && [ $ismpirun = 'yes' ]; then
    eval "$DO_PARALLEL $apipath/$apiexe" >"$1.tmp" 2>&1
  else
    "$apipath/$apiexe" >"$1.tmp" 2>&1
  fi
  apiexe_ret="$?"

  lock_file "$6"
  echo "Test $3 of $4" >> "$6"
  echo "$2" >> "$6"
  echo "QUICK executable output (stdout/stderr):" >> "$6"
  cat "$1.tmp" >> "$6"
  rm -f  "$1.tmp"
  echo >> "$6"
  echo >> "$6"
  unlock_file "$6"

  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  if [ "$apiexe_ret" -ne 0 ] && [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    echo "Error: $apiexe execution failed."
    echo ""

    # on failure, log header of failing test
    lock_file "$5"
    echo "Running test $3 of $4" | tee -a "$5"
    echo "$2" | tee -a "$5"
    unlock_file "$5"

    exit 1
  fi
}


# wrapper function for energy tests.
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number for this test
#   $4: total number of tests
#   $5: directory containing test files and scripts
#   $6: test summary log file
#   $7: test verbose log file (captures stdout/stderr from running QUICK executables)
#   $8: job slot (GNU parallel) (1-based indexing)
run_energy_test()
{
  set_test "$1" "$5" "$8"
  run_test "$1" "$2" "$3" "$4" "$6" "$7"

  check_f_error $1
  check_f_error_ret="$?"
  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  lock_file "$6"
  echo "Running test $3 of $4" | tee -a "$6"
  echo "$2" | tee -a "$6"

  if [ "$check_f_error_ret" -eq 0 ] && [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    check_energy "$1" "$5" "$6"
    check_dipole "$1" "$5" "$6"
    echo "" | tee -a "$6"
  elif [ "$check_f_error_ret" -eq 1 ]; then
    echo "SKIPPED (code not compiled with f function support)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  elif [ "$check_mpi_gpu_mismatch_ret" -eq 1 ]; then
    echo "SKIPPED (DO_PARALLEL: # MPI procs > # GPUs)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  fi
  unlock_file "$6"
  clean_up "$1"
}


# wrapper function for gradient tests.
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number for this test
#   $4: total number of tests
#   $5: directory containing test files and scripts
#   $6: test summary log file
#   $7: test verbose log file (captures stdout/stderr from running QUICK executables)
#   $8: job slot (GNU parallel) (1-based indexing)
run_grad_test()
{
  set_test "$1" "$5" "$8"
  run_test "$1" "$2" "$3" "$4" "$6" "$7"

  check_f_error $1
  check_f_error_ret="$?"
  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  lock_file "$6"
  echo "Running test $3 of $4" | tee -a "$6"
  echo "$2" | tee -a "$6"

  if [ "$check_f_error_ret" -eq 0 ] && [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    check_energy "$1" "$5" "$6"
    check_gradient "$1" "$5" "$6"
    check_dipole "$1" "$5" "$6"
    echo "" | tee -a "$6"
  elif [ "$check_f_error_ret" -eq 1 ]; then
    echo "SKIPPED (code not compiled with f function support)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  elif [ "$check_mpi_gpu_mismatch_ret" -eq 1 ]; then
    echo "SKIPPED (DO_PARALLEL: # MPI procs > # GPUs)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  fi
  unlock_file "$6"
  clean_up "$1"
}


# wrapper function for geometry optimization tests.
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number for this test
#   $4: total number of tests
#   $5: directory containing test files and scripts
#   $6: test summary log file
#   $7: test verbose log file (captures stdout/stderr from running QUICK executables)
#   $8: job slot (GNU parallel) (1-based indexing)
run_opt_test()
{
  set_test "$1" "$5" "$8"
  run_test "$1" "$2" "$3" "$4" "$6" "$7"

  check_f_error $1
  check_f_error_ret="$?"
  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  lock_file "$6"
  echo "Running test $3 of $4" | tee -a "$6"
  echo "$2" | tee -a "$6"

  if [ "$check_f_error_ret" -eq 0 ] && [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    check_opt "$1" "$5" "$6"
    check_dipole "$1" "$5" "$6"
    echo "" | tee -a "$6"
  elif [ "$check_f_error_ret" -eq 1 ]; then
    echo "SKIPPED (code not compiled with f function support)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  elif [ "$check_mpi_gpu_mismatch_ret" -eq 1 ]; then
    echo "SKIPPED (DO_PARALLEL: # MPI procs > # GPUs)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  fi
  unlock_file "$6"
  clean_up "$1"
}


# wrapper function for API tests.
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number for this test
#   $4: total number of tests
#   $5: directory containing test files and scripts
#   $6: test summary log file
#   $7: test verbose log file (captures stdout/stderr from running QUICK executables)
#   $8: job slot (GNU parallel) (1-based indexing)
run_api_test()
{
  set_test "$1" "$5" "$8"
  run_test_api "$1" "$2" "$3" "$4" "$6" "$7"

  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  lock_file "$6"
  echo "Running test $3 of $4" | tee -a "$6"
  echo "$2" | tee -a "$6"

  if [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    check_energy "$1" "$5" "$6"
    check_gradient "$1" "$5" "$6"
    echo "" | tee -a "$6"
  else
    echo "SKIPPED (DO_PARALLEL: # MPI procs > # GPUs)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  fi
  unlock_file "$6"
  clean_up "$1"
}


# wrapper function for testing restart files.
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number for this test
#   $4: total number of tests
#   $5: directory containing test files and scripts
#   $6: test summary log file
#   $7: test verbose log file (captures stdout/stderr from running QUICK executables)
#   $8: job slot (GNU parallel) (1-based indexing)
run_rw_test()
{
  set_test "$1" "$5" "$8"
  run_test "$1" "$2" "$3" "$4" "$6" "$7"

  check_f_error $1
  check_f_error_ret="$?"
  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  lock_file "$6"
  echo "Running test $3 of $4" | tee -a "$6"
  echo "$2" | tee -a "$6"

  if [ "$check_f_error_ret" -eq 0 ] && [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    check_rw "$1" "$5" "$6"
    echo "" | tee -a "$6"
  elif [ "$check_f_error_ret" -eq 1 ]; then
    echo "SKIPPED (code not compiled with f function support)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  elif [ "$check_mpi_gpu_mismatch_ret" -eq 1 ]; then
    echo "SKIPPED (DO_PARALLEL: # MPI procs > # GPUs)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  fi
  unlock_file "$6"
  clean_up "$1"
}


# wrapper function for esp tests.
#
# arguments:
#   $1: test
#   $2: test name
#   $3: test number for this test
#   $4: total number of tests
#   $5: directory containing test files and scripts
#   $6: test summary log file
#   $7: test verbose log file (captures stdout/stderr from running QUICK executables)
#   $8: job slot (GNU parallel) (1-based indexing)
run_esp_test()
{
  set_test "$1" "$5" "$8"
  run_test "$1" "$2" "$3" "$4" "$6" "$7"

  check_f_error $1
  check_f_error_ret="$?"
  check_mpi_gpu_mismatch $1
  check_mpi_gpu_mismatch_ret="$?"

  lock_file "$6"
  echo "Running test $3 of $4" | tee -a "$6"
  echo "$2" | tee -a "$6"

  if [ "$check_f_error_ret" -eq 0 ] && [ "$check_mpi_gpu_mismatch_ret" -eq 0 ]; then
    check_energy "$1" "$5" "$6"
    if [ `echo "$1" | grep '^esp_grid_'| wc -l` -gt 0 ]; then
      check_esp_grid "$1" "$5" "$6"
    elif [ `echo "$1" | grep '^esp_'| wc -l` -gt 0 ]; then
      check_esp_charge "$1" "$5" "$6"
      check_vdw_surface "$1" "$5" "$6"
    fi
    echo "" | tee -a "$6"
  elif [ "$check_f_error_ret" -eq 1 ]; then
    echo "SKIPPED (code not compiled with f function support)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  elif [ "$check_mpi_gpu_mismatch_ret" -eq 1 ]; then
    echo "SKIPPED (DO_PARALLEL: # MPI procs > # GPUs)." | tee -a "$6"
    echo "==============================================================" | tee -a "$6"
    echo "" | tee -a "$6"
  fi
  unlock_file "$6"
  clean_up "$1"
}


# check energy and/or coordinates of restart files and compare
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: log file
check_rw()
{
  if [ `echo "$1" | grep '_density_' | wc -l` -eq 1 ]; then
    grep " TOTAL ENERGY         =" "$1.out"|tail -1|awk '{print $NF}' > "$1.ene"
    grep " TOTAL ENERGY         =" "$1_read.out"|head -1|awk '{print $NF}' > "$1_read.ene"

    "$2/dacdif" -k -a '1.0e-8' "$1_read.ene" "$1.ene" | tee -a "$3"
  fi

  if [ `echo "$1" | grep '_xyz_' | wc -l` -eq 1 ]; then
    awk '/OPTIMIZED GEOMETRY IN CARTESIAN/,/FORCE/ {print}' "$1.out"| sed -n '3,$p' | head -n -2 > "$1.xyz"
    awk '/INPUT GEOMETRY/,/DISTANCE MATRIX/ {print}' "$1_read.out" | sed -n '2,$p' | head -n -1 > "$1_read.xyz"

    "$2/dacdif" -k -a '2.0e-4' "$1_read.xyz" "$1.xyz" | tee -a "$3"
  fi
}


# check electronic, nuclear, and total energy output from test.
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: test summary log file
check_energy()
{
  awk '/Begin Energy Calculation/,/End Energy calculation/ {print}' "$1.ref.out" > "$1.ref.ene"
  awk '/Begin Energy Calculation/,/End Energy calculation/ {print}' "$1.out" > "$1.ene"

  "$2/dacdif" -k -a '4.0e-5' "$1.ref.ene" "$1.ene" | tee -a "$3"
}


# check ESP charge output from test.
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: test summary log file
check_esp_charge()
{
  awk '/ESP charges:/,/Net charge/ {print}' "$1.ref.out" > "$1.ref.charge"
  awk '/ESP charges:/,/Net charge/ {print}' "$1.out" > "$1.charge"

  "$2/dacdif" -k -a '1.0e-5' "$1.ref.charge" "$1.charge" | tee -a "$3"
}

# check ESP on points on van der Waals surface output from test.
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: test summary log file
check_vdw_surface()
{
  "$2/dacdif" -k -a '2.0e-7' "$1.ref.vdw" "$1.vdw" | tee -a "$3"
}

# check ESP on external points output from test.
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: test summary log file
check_esp_grid()
{
  "$2/dacdif" -k -a '2.0e-7' "$1.ref.esp" "$1.esp" | tee -a "$3"
}

# check nuclear and point charge gradients output from test.
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: test summary log file
check_gradient()
{
  awk '/Begin Gradient Calculation/,/End Gradient Calculation/ {print}' "$1.ref.out" > "$1.ref.grad"
  awk '/Begin Gradient Calculation/,/End Gradient Calculation/ {print}' "$1.out" > "$1.grad"

  "$2/dacdif" -k -a '4.0e-3' "$1.ref.grad" "$1.grad" | tee -a "$3"
}


# check optimized geometry and force element output from test.
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: test summary log file
check_opt()
{
  awk '/GEOMETRY INFORMATION/,/Finish Optimization Job/ {print}' "$1.ref.out" > "$1.ref.opt"
  awk '/GEOMETRY INFORMATION/,/Finish Optimization Job/ {print}' "$1.out" > "$1.opt"

  "$2/dacdif" -k -a '4.0e-3' "$1.ref.opt" "$1.opt" | tee -a "$3"
}


# check mulliken charges and dipole output from test.
# accuracy sets the tolerance. 
#
# arguments:
#   $1: test name
#   $2: directory containing test files and scripts
#   $3: test summary log file
check_dipole()
{
  accuracy='4.0e-3'

  awk '/Begin Charge and Dipole Calculation/,/End Charge and Dipole Calculation/ {print}' "$1.ref.out" > "$1.ref.dipole"
  awk '/Begin Charge and Dipole Calculation/,/End Charge and Dipole Calculation/ {print}' "$1.out" > "$1.dipole"

  "$2/dacdif" -k -a "$accuracy" "$1.ref.dipole" "$1.dipole" | tee -a "$3"
}


# function to clean up files from test
#
# arguments:
#   $1: test name
clean_up()
{
  rm -f $1.ref.out $1.ref.vdw $1.ref.esp $1.in $1.tmp ddtmp.$1* $1.*ene $1.*grad $1.*dipole $1.*opt $1.*charge $1.*xyz
  rm -f $1_read.ref.out $1_read.in $1_read.*ene $1_read.*opt
}


# function to report summary
print_summary()
{
  sum_header="======================== Test Summary ========================"
  sum_footer="=============================================================="  

  echo "$sum_header"
  echo ""

  if [ "$log" = 'yes' ]; then
    echo "$sum_header" > $QUICK_HOME/.quick.runtest.summary.log
    echo "" >> $QUICK_HOME/.quick.runtest.summary.log
  fi

  for buildtype in $buildtypes; do
    total_ene=0
    total_grad=0
    total_opt=0
    total_api=0
    total_rw=0
    total_esp=0
    failed_ene=0
    failed_grad=0
    failed_opt=0
    failed_api=0
    failed_rw=0
    failed_esp=0
 
    # set testlist
    set_qexe_testlist "$buildtype"
 
    # get the number of tests to run
    get_total_tests "$test_ene" "$test_grad" "$test_opt" "$test_api" "$test_rw" "$test_esp"
 
    # grab stuff from temporary log files
    sed -n '/'$buildtype' version started/,/All '$buildtype' tests are done/p' $QUICK_HOME/.quick.${buildtype}.runtest.log > .quick.runtest.${buildtype}.summary.tmp1
 
    for i in `seq 1 $total_tests`; do
      if [ "$i" -lt "$total_tests" ]; then
        j=$(($i+1))
        sed -n '/Running test '$i' of '$total_tests'/,/Running test /p' .quick.runtest.${buildtype}.summary.tmp1 > .quick.runtest.${buildtype}.summary.tmp2
      elif [ "$i" -eq "$total_tests" ]; then
        sed -n '/Running test '$total_tests'/,/All '$buildtype' tests are done/p' .quick.runtest.${buildtype}.summary.tmp1 > .quick.runtest.${buildtype}.summary.tmp2
      fi
  
      if [ `sed -n '/energy test/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
        total_ene=$(($total_ene+1))
        if [ `sed -n '/possible FAILURE/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
          failed_ene=$(($failed_ene+1))
        fi
        
      elif [ `sed -n '/gradient test/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
        total_grad=$(($total_grad+1))
        if [ `sed -n '/possible FAILURE/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
          failed_grad=$(($failed_grad+1))
        fi
      elif [ `sed -n '/geometry optimization test/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
        total_opt=$(($total_opt+1))
        if [ `sed -n '/possible FAILURE/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
          failed_opt=$(($failed_opt+1))
        fi
      elif [ `sed -n '/API test/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
        total_api=$(($total_api+1))
        if [ `sed -n '/possible FAILURE/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
          failed_api=$(($failed_api+1))
        fi
      elif [ `sed -n '/RW test/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
        total_rw=$(($total_rw+1))
        if [ `sed -n '/possible FAILURE/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
          failed_rw=$(($failed_rw+1))
        fi
      elif [ `sed -n '/ESP test/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
        total_esp=$(($total_esp+1))
        if [ `sed -n '/possible FAILURE/p' .quick.runtest.${buildtype}.summary.tmp2 | wc -l` -gt 0 ]; then
          failed_esp=$(($failed_esp+1))
        fi
      fi
      
      rm -f .quick.runtest.${buildtype}.summary.tmp2
    done
    
    failed_total=$(($failed_ene+$failed_grad+$failed_opt+$failed_api+$failed_rw+$failed_esp))

    # update cumulative failed tests too
    ncum_failed_tests=$(($ncum_failed_tests+$failed_total))

    echo "$buildtype version:" > .quick.runtest.${buildtype}.summary.tmp0
    echo "    Energy tests: $failed_ene/$total_ene (failed/total)" >> .quick.runtest.${buildtype}.summary.tmp0
    echo "    Gradient tests: $failed_grad/$total_grad (failed/total)" >> .quick.runtest.${buildtype}.summary.tmp0
    echo "    Optimization tests: $failed_opt/$total_opt (failed/total)" >> .quick.runtest.${buildtype}.summary.tmp0
    echo "    API tests: $failed_api/$total_api (failed/total)" >> .quick.runtest.${buildtype}.summary.tmp0
    echo "    RW tests: $failed_rw/$total_rw (failed/total)" >> .quick.runtest.${buildtype}.summary.tmp0
    echo "    ESP tests: $failed_esp/$total_esp (failed/total)" >> .quick.runtest.${buildtype}.summary.tmp0
    echo "    Total tests: $failed_total/$total_tests (failed/total)" >> .quick.runtest.${buildtype}.summary.tmp0
    echo "" >> .quick.runtest.${buildtype}.summary.tmp0
 
    cat .quick.runtest.${buildtype}.summary.tmp0
 
    if [ "$log" = 'yes' ]; then 
      cat .quick.runtest.${buildtype}.summary.tmp0 >> $QUICK_HOME/.quick.runtest.summary.log
    fi
 
    rm -f .quick.runtest.${buildtype}.summary.tmp1 .quick.runtest.${buildtype}.summary.tmp0
  done

  echo "$sum_footer"

  if [ "$log" = 'yes' ]; then
    echo "$sum_footer" >> $QUICK_HOME/.quick.runtest.summary.log
  fi
}


# Function to skip F tests if the code wasnt compiled with support
#
# arguments:
#   $1: test name
check_f_error()
{
    f_error_string=`grep 'Error: Support for F functions is disabled' "$1.out"`

    if [ -z "$f_error_string" ]; then ret=0 ; else ret=1 ; fi

    return "$ret"
}


# Function to skip tests if the MPI+CUDA/MPI+HIP codes were executed with
# more MPI processes than available GPUs on the system
#
# arguments:
#   $1: test name
check_mpi_gpu_mismatch()
{
    mpi_gpu_error_string=`grep 'Error: Number of launched processes is greater than the available number of GPUs.' "$1.out"`

    if [ -z "$mpi_gpu_error_string" ]; then ret=0 ; else ret=1 ; fi

    return "$ret"
}


check_for_req_deps "cat" "date" "echo" "rm" "seq" "tee" "touch" "wc" "awk" "sed"

#  !---------------------------------------------------------------------!
#  ! Read input                                                          !
#  !---------------------------------------------------------------------
while [ $# -gt 0 ]; do
  case "$1" in
    --serial)      serial='yes'; buildtypes="$buildtypes serial";;
    --mpi)         mpi='yes'; buildtypes="$buildtypes mpi";;
    --cuda)        cuda='yes'; buildtypes="$buildtypes cuda";;
    --cudampi)     cudampi='yes'; buildtypes="$buildtypes cudampi";;
    --hip)         hip='yes'; buildtypes="$buildtypes hip";;
    --hipmpi)      hipmpi='yes'; buildtypes="$buildtypes hipmpi";;
    --ene)         test_ene='yes';uspec_test='yes';;
    --grad)        test_grad='yes';uspec_test='yes';;
    --opt)         test_opt='yes';uspec_test='yes';;
    --api)         test_api='yes';uspec_test='yes';;
    --rw)          test_rw='yes';uspec_test='yes';;
    --esp)         test_esp='yes';uspec_test='yes';;
    --full)        test_length='full';;
    --nolog)       log='no';;   
    -h| -H| -help| --help) print_help;;
     *) 
         echo  "Neglecting unknown flag: $1";;
  esac
  shift
done


#  !---------------------------------------------------------------------!
#  ! Check directories & executables                                     !
#  !---------------------------------------------------------------------!
if [ ! -d "$qbindir" ]; then
  if [ "$AMBERHOME" != "" ]; then
    # Assume we are in Amber
    qbindir=$AMBERHOME/bin
  else
    echo  "Error: QUICK bin folder not found. "
    exit 1
  fi
fi

if [ ! -d "$qbasisdir" ]; then
  echo  "Error: QUICK basis folder not found. "
  exit 1
else
  export QUICK_BASIS=$qbasisdir
fi

if [ ! -d "$testdir" ]; then
  echo  "Error: QUICK test folder not found. "
  exit 1
fi

if [ "$serial" = 'yes' -o "$mpi" = 'yes' -o "$cuda" = 'yes' -o "$cudampi" = 'yes' -o "$hip" = 'yes' -o "$hipmpi" = 'yes' ]; then
  if [ "$serial" = 'yes' ]; then
    if [ ! -x "$qbindir/quick" ]; then
      echo  "Error: $qbindir/quick not found."
      exit 1
    fi
    if ! [ -x "$testdir/test-api" -o -x "$qbindir/test-api" ]; then
      echo  "Error: test-api not found in $testdir or $qbindir."
      exit 1
    fi
  fi

  if [ "$mpi" = 'yes' ]; then
    if [ ! -x "$qbindir/quick.MPI" ]; then
      echo  "Error: $qbindir/quick.MPI not found."
      exit 1
    fi
    if ! [ -x "$testdir/test-api.MPI" -o -x "$qbindir/test-api.MPI" ]; then
      echo  "Error: test-api.MPI not found in $testdir or $qbindir."
      exit 1
    fi
  fi

  if [ "$cuda" = 'yes' ]; then
    if [ ! -x "$qbindir/quick.cuda" ]; then
      echo  "Error: $qbindir/quick.cuda not found."
      exit 1
    fi
    if ! [ -x "$testdir/test-api.cuda" -o -x "$qbindir/test-api.cuda" ]; then
      echo  "Error: test-api.cuda not found in $testdir or $qbindir."
      exit 1
    fi
  fi

  if [ "$cudampi" = 'yes' ]; then
    if [ ! -x "$qbindir/quick.cuda.MPI" ]; then
      echo  "Error: $qbindir/quick.cuda.MPI not found."
      exit 1
    fi
    if ! [ -x "$testdir/test-api.cuda.MPI" -o -x "$qbindir/test-api.cuda.MPI" ]; then
      echo  "Error: test-api.cuda.MPI not found in $testdir or $qbindir."
      exit 1
    fi
  fi

  if [ "$hip" = 'yes' ]; then
    if [ ! -x "$qbindir/quick.hip" ]; then
      echo  "Error: $qbindir/quick.hip not found."
      exit 1
    fi
    if ! [ -x "$testdir/test-api.hip" -o -x "$qbindir/test-api.hip" ]; then
      echo  "Error: test-api.hip not found in $testdir or $qbindir."
      exit 1
    fi
  fi

  if [ "$hipmpi" = 'yes' ]; then
    if [ ! -x "$qbindir/quick.hip.MPI" ]; then
      echo  "Error: $qbindir/quick.hip.MPI not found."
      exit 1
    fi
    if ! [ -x "$testdir/test-api.hip.MPI" -o -x "$qbindir/test-api.hip.MPI" ]; then
      echo  "Error: test-api.hip.MPI not found in $testdir or $qbindir."
      exit 1
    fi
  fi

else
  # automatically check for executables
  if [ -x "$qbindir/quick.cuda.MPI" ]; then
    cudampi='yes'
    buildtypes="$buildtypes cudampi"
  fi

  if [ -x "$qbindir/quick.cuda" ]; then
    cuda='yes'
    buildtypes="$buildtypes cuda"
  fi

  if [ -x "$qbindir/quick.hip.MPI" ]; then
    hipmpi='yes'
    buildtypes="$buildtypes hipmpi"
  fi

  if [ -x "$qbindir/quick.hip" ]; then
    hip='yes'
    buildtypes="$buildtypes hip"
  fi

  if [ -x "$qbindir/quick.MPI" ]; then
    mpi='yes'
    buildtypes="$buildtypes mpi"
  fi

  if [ -x "$qbindir/quick" ]; then
    serial='yes'
    buildtypes="$buildtypes serial"
  fi

  if [ "$serial" = 'no' -a "$mpi" = 'no' -a "$cuda" = 'no' -a "$cudampi" = 'no' -a "$hip" = 'no' -a "$hipmpi" = 'no' ]; then
    echo  "Error: No QUICK executables found in $qbindir. "
    exit 1
  fi
fi

if [ ! -f "$testdir/testlist_short.txt" ]; then
  echo  "Error: testlist_short.txt not found in $testdir. "
  exit 1
fi

if [ ! -f "$testdir/testlist_full.txt" ]; then
  echo  "Error: testlist_full.txt not found in $testdir. "
  exit 1
fi

if [ ! -f "$testdir/testlist_short_gpu.txt" ]; then
  echo  "Error: testlist_short_gpu.txt not found in $testdir. "
  exit 1
fi

if [ ! -f "$testdir/testlist_full_gpu.txt" ]; then
  echo  "Error: testlist_full_gpu.txt not found in $testdir. "
  exit 1
fi

# check for mpirun 
if [ "$mpi" = 'yes' -o "$cudampi" = 'yes' -o "$hipmpi" = 'yes' ]; then
  mpimsg=""
  if [ -z "$DO_PARALLEL" ]; then
    echo "Error: MPI/MPI+X tests are requested but DO_PARALLEL variable is not set."
    exit 1
  else
    ismpirun='yes'
    mpimsg="MPI command: $DO_PARALLEL"
  fi
 
  echo ""
  echo "$mpimsg"   
 
  if [ "$mpi" = 'yes' ]; then
    echo "" >> $QUICK_HOME/.quick.mpi.runtest.log
    echo "$mpimsg" >> $QUICK_HOME/.quick.mpi.runtest.log 
  fi
 
  if [ "$cudampi" = 'yes' ]; then
    echo "" >> $QUICK_HOME/.quick.cudampi.runtest.log
    echo "$mpimsg" >> $QUICK_HOME/.quick.cudampi.runtest.log
  fi

  if [ "$hipmpi" = 'yes' ]; then
    echo "" >> $QUICK_HOME/.quick.hipmpi.runtest.log
    echo "$mpimsg" >> $QUICK_HOME/.quick.hipmpi.runtest.log
  fi
fi

# check for GNU parallel
if [ -n "$PARALLEL_TEST_COUNT" ]; then
  check_for_req_deps "parallel" "cut" "ln" "sleep"

  case $PARALLEL_TEST_COUNT in
    ''|*[!0-9]*) is_integer='no';;
    *) is_integer='yes';;
  esac

  if [ "$is_integer" = 'no' ]; then
    echo "Error: PARALLEL_TEST_COUNT must be set to an integer value."
    exit 1;
  elif [ "$PARALLEL_TEST_COUNT" -le '0' ]; then
    echo "Error: PARALLEL_TEST_COUNT must be greater than zero."
    exit 1;
  fi

  if [ "$cuda" = 'yes' -o "$cudampi" = 'yes' ]; then
    if [ -z "$CUDA_VISIBLE_DEVICES" ]; then
      echo "Error: set the GPUs to use with CUDA_VISIBLE_DEVICES (# GPUs >= PARALLEL_TEST_COUNT)."
      exit 1;
    fi
  elif [ "$hip" = 'yes' -o "$hipmpi" = 'yes' ]; then
    if [ -z "$HIP_VISIBLE_DEVICES" ] && [ -z "$CUDA_VISIBLE_DEVICES" ]; then
      echo "Error: set the GPUs to use with HIP_VISIBLE_DEVICES/CUDA_VISIBLE_DEVICES (# GPUs >= PARALLEL_TEST_COUNT)."
      exit 1;
    fi
  fi

  has_parallel='yes'

  # required exports for GNU parallel to have visibility of global shell varaibles and functions
  #
  # note: function exporting for invocation with GNU parallel is bash-specific;
  #       an alternative would be to install and use env_parallel (which for non-bash shells
  #       utilizes a export and eval approach for string representation of shell functions)
  export buildtype qbindir qexe apipath apiexe ismpirun has_parallel cuda cudampi hip hipmpi
  export -f set_job_gpus set_test run_test run_test_api run_energy_test run_grad_test run_opt_test run_api_test \
	  run_rw_test run_esp_test check_rw check_energy check_gradient check_opt \
          check_esp_charge check_esp_grid check_vdw_surface check_dipole \
          clean_up check_f_error check_mpi_gpu_mismatch lock_file unlock_file
fi

#  !---------------------------------------------------------------------!
#  ! Create required directories                                         !
#  !---------------------------------------------------------------------!
if [ ! -d "$testdir/runs" ]; then
  mkdir -p "$testdir/runs"
fi

for buildtype in $buildtypes; do
  rm -rf "$testdir/runs/$buildtype"
  mkdir -p "$testdir/runs/$buildtype"
done

#  !---------------------------------------------------------------------!
#  ! Set test tyeps                                                      !
#  !---------------------------------------------------------------------!
if [ "$uspec_test" = 'no' ]; then
  test_ene='yes'
  test_grad='yes'
  test_opt='yes'
  test_api='yes'
  test_rw='yes'
  test_esp='yes'
fi

#  !---------------------------------------------------------------------!
#  ! Run tests                                                           !
#  !---------------------------------------------------------------------!
cd "$testdir"
for buildtype in $buildtypes; do
  cdate=`date +'%m/%d/%Y'`
  ctime=`date +'%r'`

  echo "" | tee -a $QUICK_HOME/.quick.${buildtype}.runtest.log
  echo  "Testing $QUICK_VERSION $buildtype version started on $cdate at $ctime. " | tee -a $QUICK_HOME/.quick.${buildtype}.runtest.log
  echo "" | tee -a $QUICK_HOME/.quick.${buildtype}.runtest.log

  echo "" >> $QUICK_HOME/.quick.${buildtype}.runtest-verbose.log
  echo  "Testing $QUICK_VERSION $buildtype version started on $cdate at $ctime. " >> $QUICK_HOME/.quick.${buildtype}.runtest-verbose.log
  echo "" >> $QUICK_HOME/.quick.${buildtype}.runtest-verbose.log

  # set qexe and testlist
  set_qexe_testlist "$buildtype"

  # get the number of tests to run
  get_total_tests "$test_ene" "$test_grad" "$test_opt" "$test_api" "$test_rw" "$test_esp"

  cd "$testdir/runs/$buildtype"

  if [ $has_parallel = 'yes' ]; then
    # ensure no leftover lock files from failed previous runs
    rm -f "$QUICK_HOME/.quick.${buildtype}.runtest.log.lock" "$QUICK_HOME/.quick.${buildtype}.runtest.log.deleteme"
  fi

  # Run energy tests
  tc_start=0
  tc_end=0

  if [ "$test_ene" = 'yes' ]; then
    tc_start=$(($tc_end+1))
    tc_end=$(($tc_end+$tot_ene_tests))
    if [ $has_parallel = 'no' ]; then
      for tc in `seq $tc_start $tc_end`; do
        run_energy_test "${tests[$(($tc-1))]}" "${test_names[$(($tc-1))]}" "$tc" "$total_tests" \
		"$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
                "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log"
      done
    elif [ $has_parallel = 'yes' ]; then
      parallel --keep-order --group --jobs "$PARALLEL_TEST_COUNT" --xapply --will-cite run_energy_test {1} {2} {3} \
	      "$total_tests" "$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
	      "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log" {%} \
	      ::: "${tests[@]:$(($tc_start-1)):$tot_ene_tests}" ::: "${test_names[@]:$(($tc_start-1)):$tot_ene_tests}" \
	      ::: `seq $tc_start $tc_end`
    fi
  fi

  # Run gradient tests
  if [ "$test_grad" = 'yes' ]; then
    tc_start=$(($tc_end+1))
    tc_end=$(($tc_end+$tot_grad_tests))
    if [ $has_parallel = 'no' ]; then
      for tc in `seq $tc_start $tc_end`; do
        run_grad_test "${tests[$(($tc-1))]}" "${test_names[$(($tc-1))]}" "$tc" "$total_tests" \
		"$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
                "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log"
      done
    elif [ $has_parallel = 'yes' ]; then
      parallel --keep-order --group --jobs "$PARALLEL_TEST_COUNT" --xapply --will-cite run_grad_test {1} {2} {3} \
	      "$total_tests" "$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
	      "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log" {%} \
	      ::: "${tests[@]:$(($tc_start-1)):$tot_grad_tests}" ::: "${test_names[@]:$(($tc_start-1)):$tot_grad_tests}" \
	      ::: `seq $tc_start $tc_end`
    fi
  fi

  # Run geometry optimization tests
  if [ "$test_opt" = 'yes' ]; then
    tc_start=$(($tc_end+1))
    tc_end=$(($tc_end+$tot_opt_tests))
    if [ $has_parallel = 'no' ]; then
      for tc in `seq $tc_start $tc_end`; do
        run_opt_test "${tests[$(($tc-1))]}" "${test_names[$(($tc-1))]}" "$tc" "$total_tests" \
		"$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
                "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log"
      done
    elif [ $has_parallel = 'yes' ]; then
      parallel --keep-order --group --jobs "$PARALLEL_TEST_COUNT" --xapply --will-cite run_opt_test {1} {2} {3} \
	      "$total_tests" "$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
	      "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log" {%} \
	      ::: "${tests[@]:$(($tc_start-1)):$tot_opt_tests}" ::: "${test_names[@]:$(($tc_start-1)):$tot_opt_tests}" \
	      ::: `seq $tc_start $tc_end`
    fi
  fi

  # Run api tests
  if [ "$test_api" = 'yes' ]; then
    tc_start=$(($tc_end+1))
    tc_end=$(($tc_end+$tot_api_tests))
    if [ $has_parallel = 'no' ]; then
      for tc in `seq $tc_start $tc_end`; do
        run_api_test "${tests[$(($tc-1))]}" "${test_names[$(($tc-1))]}" "$tc" "$total_tests" \
		"$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
                "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log"
      done
    elif [ $has_parallel = 'yes' ]; then
      parallel --keep-order --group --jobs "$PARALLEL_TEST_COUNT" --xapply --will-cite run_api_test {1} {2} {3} \
	      "$total_tests" "$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
	      "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log" {%} \
	      ::: "${tests[@]:$(($tc_start-1)):$tot_api_tests}" ::: "${test_names[@]:$(($tc_start-1)):$tot_api_tests}" \
	      ::: `seq $tc_start $tc_end`
    fi
  fi

  # Run restart tests
  if [ "$test_rw" = 'yes' ]; then
    tc_start=$(($tc_end+1))
    tc_end=$(($tc_end+$tot_rw_tests))
    if [ $has_parallel = 'no' ]; then
      for tc in `seq $tc_start $tc_end`; do
        run_rw_test "${tests[$(($tc-1))]}" "${test_names[$(($tc-1))]}" "$tc" "$total_tests" \
		"$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
                "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log"
      done
    elif [ $has_parallel = 'yes' ]; then
      parallel --keep-order --group --jobs "$PARALLEL_TEST_COUNT" --xapply --will-cite run_rw_test {1} {2} {3} \
	      "$total_tests" "$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
              "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log" {%} \
	      ::: "${tests[@]:$(($tc_start-1)):$tot_rw_tests}" ::: "${test_names[@]:$(($tc_start-1)):$tot_rw_tests}" \
	      ::: `seq $tc_start $tc_end`
    fi
  fi

  # Run ESP test
  if [ "$test_esp" = 'yes' ]; then
    tc_start=$(($tc_end+1))
    tc_end=$(($tc_end+$tot_esp_tests))
    if [ $has_parallel = 'no' ]; then
      for tc in `seq $tc_start $tc_end`; do
        run_esp_test "${tests[$(($tc-1))]}" "${test_names[$(($tc-1))]}" "$tc" "$total_tests" \
		"$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
                "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log"
      done
    elif [ $has_parallel = 'yes' ]; then
      parallel --keep-order --group --jobs "$PARALLEL_TEST_COUNT" --xapply --will-cite run_esp_test {1} {2} {3} \
	      "$total_tests" "$testdir" "$QUICK_HOME/.quick.${buildtype}.runtest.log" \
	      "$QUICK_HOME/.quick.${buildtype}.runtest-verbose.log" {%} \
	      ::: "${tests[@]:$(($tc_start-1)):$tot_esp_tests}" ::: "${test_names[@]:$(($tc_start-1)):$tot_esp_tests}" \
	      ::: `seq $tc_start $tc_end`
    fi
  fi

  echo "All $buildtype tests are done. The output files are located in $testdir/runs/$buildtype." | tee -a $QUICK_HOME/.quick.${buildtype}.runtest.log
  echo "" | tee -a $QUICK_HOME/.quick.${buildtype}.runtest.log

  cd "$testdir"
done
  
cd $installdir

# print test summary
print_summary

# create final .log file or delete temp .log files
if [ "$log" = 'yes' ]; then
  touch runtest.log runtest-verbose.log
  for buildtype in $buildtypes; do
    cat $QUICK_HOME/.quick.${buildtype}.runtest.log >> $QUICK_HOME/runtest.log
    cat $QUICK_HOME/.quick.${buildtype}.runtest-verbose.log >> $QUICK_HOME/runtest-verbose.log
    rm -f $QUICK_HOME/.quick.${buildtype}.runtest.log $QUICK_HOME/.quick.${buildtype}.runtest-verbose.log
  done
  cat $QUICK_HOME/.quick.runtest.summary.log >> $QUICK_HOME/runtest.log
  rm -f $QUICK_HOME/.quick.runtest.summary.log

  echo "Output of runtest script has been written into $QUICK_HOME/runtest.log file."
  echo "Verbose output of runtest script has been written into $QUICK_HOME/runtest-verbose.log file."
else
  for buildtype in $buildtypes; do
    rm -f $QUICK_HOME/.quick.${buildtype}.runtest.log $QUICK_HOME/.quick.${buildtype}.runtest-verbose.log 
  done
fi

# exit if tests are failed.
if [ $ncum_failed_tests -gt 0 ]; then
  exit 1
else
  exit 0
fi
