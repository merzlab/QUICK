/*    
  This file was generated automatically with ./scripts/maple2c.pl.   
  Do not edit this file directly as it can be overwritten!!   
   
  This Source Code Form is subject to the terms of the Mozilla Public   
  License, v. 2.0. If a copy of the MPL was not distributed with this   
  file, You can obtain one at http://mozilla.org/MPL/2.0/.   
   
  Maple version     : Maple 2016 (X86 64 LINUX)   
  Maple source      : ./maple/lda_c_lp96.mpl   
  Type of functional: work_lda   
*/   
   
#ifdef DEVICE   
__device__ static void   
xc_lda_c_lp96_func0_kernel(const void *p, xc_lda_work_t *r)   
#else   
static void   
func0(const xc_func_type *p, xc_lda_work_t *r)   
#endif   
{   
  double t1, t2, t3, t4, t5, t6, t9, t10;   
  double t15, t16, t17, t22, t25, t26, t27, t31;   
  double t34, t38, t39, t41, t42, t45, t46, t47;   
  double t52, t58, t66, t68, t69, t74;   
   
  lda_c_lp96_params *params;   
   
#ifndef DEVICE   
  assert(p->params != NULL);   
  params = (lda_c_lp96_params * )(p->params);   
#else   
  params = (lda_c_lp96_params * )(p);   
#endif   
   
  t1 = M_CBRT3;   
  t2 = t1 * t1;   
  t3 = params->C2 * t2;   
  t4 = M_CBRT4;   
  t5 = 0.1e1 / 0.31415926535897932385e1;   
  t6 = r->rs * r->rs;   
  t9 = t5 / t6 / r->rs;   
  t10 = POW_1_3(t9);   
  t15 = params->C3 * t1;   
  t16 = t4 * t4;   
  t17 = t10 * t10;   
  r->f = params->C1 + t3 * t4 / t10 / 0.3e1 + t15 * t16 / t17 / 0.3e1;   
   
  if(r->order < 1) return;   
   
  t22 = t3 * t4;   
  t25 = 0.1e1 / t10 / t9 * t5;   
  t26 = t6 * t6;   
  t27 = 0.1e1 / t26;   
  t31 = t15 * t16;   
  t34 = 0.1e1 / t17 / t9 * t5;   
  r->dfdrs = t22 * t25 * t27 / 0.3e1 + 0.2e1 / 0.3e1 * t31 * t34 * t27;   
   
  if(r->order < 2) return;   
   
  t38 = 0.31415926535897932385e1 * 0.31415926535897932385e1;   
  t39 = 0.1e1 / t38;   
  t41 = 0.1e1 / t26 / t6;   
  t42 = t39 * t41;   
  t45 = 0.1e1 / t10 / t42 * t39;   
  t46 = t26 * t26;   
  t47 = 0.1e1 / t46;   
  t52 = 0.1e1 / t26 / r->rs;   
  t58 = 0.1e1 / t17 / t42 * t39;   
  r->d2fdrs2 = 0.4e1 / 0.3e1 * t22 * t45 * t47 - 0.4e1 / 0.3e1 * t22 * t25 * t52 + 0.10e2 / 0.3e1 * t31 * t58 * t47 - 0.8e1 / 0.3e1 * t31 * t34 * t52;   
   
  if(r->order < 3) return;   
   
  t66 = 0.1e1 / t38 / 0.31415926535897932385e1;   
  t68 = 0.1e1 / t46 / r->rs;   
  t69 = t66 * t68;   
  t74 = 0.1e1 / t46 / t26;   
  r->d3fdrs3 = 0.28e2 / 0.3e1 * t22 / t10 / t69 * t66 * t74 - 0.16e2 * t22 * t45 * t68 + 0.20e2 / 0.3e1 * t22 * t25 * t41 + 0.80e2 / 0.3e1 * t31 / t17 / t69 * t66 * t74 - 0.40e2 * t31 * t58 * t68 + 0.40e2 / 0.3e1 * t31 * t34 * t41;   
   
  if(r->order < 4) return;   
   
   
}   
   
#ifdef DEVICE   
__device__ static void   
xc_lda_c_lp96_func1_kernel(const void *p, xc_lda_work_t *r)   
#else   
static void   
func1(const xc_func_type *p, xc_lda_work_t *r)   
#endif   
{   
  double t1, t2, t3, t4, t5, t6, t9, t10;   
  double t15, t16, t17, t22, t25, t26, t27, t31;   
  double t34, t38, t39, t41, t42, t45, t46, t47;   
  double t52, t58, t66, t68, t69, t74;   
   
  lda_c_lp96_params *params;   
   
#ifndef DEVICE   
  assert(p->params != NULL);   
  params = (lda_c_lp96_params * )(p->params);   
#else   
  params = (lda_c_lp96_params * )(p);   
#endif   
   
  t1 = M_CBRT3;   
  t2 = t1 * t1;   
  t3 = params->C2 * t2;   
  t4 = M_CBRT4;   
  t5 = 0.1e1 / 0.31415926535897932385e1;   
  t6 = r->rs * r->rs;   
  t9 = t5 / t6 / r->rs;   
  t10 = POW_1_3(t9);   
  t15 = params->C3 * t1;   
  t16 = t4 * t4;   
  t17 = t10 * t10;   
  r->f = params->C1 + t3 * t4 / t10 / 0.3e1 + t15 * t16 / t17 / 0.3e1;   
   
  if(r->order < 1) return;   
   
  t22 = t3 * t4;   
  t25 = 0.1e1 / t10 / t9 * t5;   
  t26 = t6 * t6;   
  t27 = 0.1e1 / t26;   
  t31 = t15 * t16;   
  t34 = 0.1e1 / t17 / t9 * t5;   
  r->dfdrs = t22 * t25 * t27 / 0.3e1 + 0.2e1 / 0.3e1 * t31 * t34 * t27;   
  r->dfdz = 0.0e0;   
   
  if(r->order < 2) return;   
   
  t38 = 0.31415926535897932385e1 * 0.31415926535897932385e1;   
  t39 = 0.1e1 / t38;   
  t41 = 0.1e1 / t26 / t6;   
  t42 = t39 * t41;   
  t45 = 0.1e1 / t10 / t42 * t39;   
  t46 = t26 * t26;   
  t47 = 0.1e1 / t46;   
  t52 = 0.1e1 / t26 / r->rs;   
  t58 = 0.1e1 / t17 / t42 * t39;   
  r->d2fdrs2 = 0.4e1 / 0.3e1 * t22 * t45 * t47 - 0.4e1 / 0.3e1 * t22 * t25 * t52 + 0.10e2 / 0.3e1 * t31 * t58 * t47 - 0.8e1 / 0.3e1 * t31 * t34 * t52;   
  r->d2fdrsz = 0.0e0;   
  r->d2fdz2 = 0.0e0;   
   
  if(r->order < 3) return;   
   
  t66 = 0.1e1 / t38 / 0.31415926535897932385e1;   
  t68 = 0.1e1 / t46 / r->rs;   
  t69 = t66 * t68;   
  t74 = 0.1e1 / t46 / t26;   
  r->d3fdrs3 = 0.28e2 / 0.3e1 * t22 / t10 / t69 * t66 * t74 - 0.16e2 * t22 * t45 * t68 + 0.20e2 / 0.3e1 * t22 * t25 * t41 + 0.80e2 / 0.3e1 * t31 / t17 / t69 * t66 * t74 - 0.40e2 * t31 * t58 * t68 + 0.40e2 / 0.3e1 * t31 * t34 * t41;   
  r->d3fdrs2z = 0.0e0;   
  r->d3fdrsz2 = 0.0e0;   
  r->d3fdz3 = 0.0e0;   
   
  if(r->order < 4) return;   
   
   
}   
   
#ifdef DEVICE   
__device__ void   
xc_lda_c_lp96_func_kernel(const void *p, xc_lda_work_t *r)   
{   
  if(r->nspin == XC_UNPOLARIZED)   
xc_lda_c_lp96_func0_kernel(p, r);   
  else   
xc_lda_c_lp96_func1_kernel(p, r);   
}   
#else   
void    
xc_lda_c_lp96_func(const xc_func_type *p, xc_lda_work_t *r)   
{   
  if(p->nspin == XC_UNPOLARIZED)   
    func0(p, r);   
  else   
    func1(p, r);   
}   
#endif   
   
#ifndef DEVICE   
#define maple2c_order 3   
#define maple2c_func  xc_lda_c_lp96_func   
#define kernel_id 8 
#endif
