/*    
  This file was generated automatically with ../scripts/maple2c.pl.   
  Do not edit this file directly as it can be overwritten!!   
   
  This Source Code Form is subject to the terms of the Mozilla Public   
  License, v. 2.0. If a copy of the MPL was not distributed with this   
  file, You can obtain one at http://mozilla.org/MPL/2.0/.   
   
  Maple version     : Maple 2016 (X86 64 LINUX)   
  Maple source      : ../maple/lda_xc_teter93.mpl   
  Type of functional: work_lda   
*/   
   
#ifdef DEVICE   
__device__ static void   
xc_lda_xc_teter93_func0_kernel(const void *p, xc_lda_work_t *r)   
#else   
static void   
func0(const xc_func_type *p, xc_lda_work_t *r)   
#endif   
{   
  double t2, t4, t6, t10, t12, t13, t17, t19;   
  double t20, t21, t25, t28, t30, t34, t35, t36;   
  double t41, t52;   
   
   
  t2 = r->rs * r->rs;   
  t4 = t2 * r->rs;   
  t6 = 0.4581652932831429e0 + 0.2217058676663745e1 * r->rs + 0.7405551735357053e0 * t2 + 0.1968227878617998e-1 * t4;   
  t10 = t2 * t2;   
  t12 = 0.10000000000000000e1 * r->rs + 0.4504130959426697e1 * t2 + 0.1110667363742916e1 * t4 + 0.2359291751427506e-1 * t10;   
  t13 = 0.1e1 / t12;   
  r->f = -t6 * t13;   
   
  if(r->order < 1) return;   
   
  t17 = 0.2217058676663745e1 + 0.14811103470714106e1 * r->rs + 0.5904683635853994e-1 * t2;   
  t19 = t12 * t12;   
  t20 = 0.1e1 / t19;   
  t21 = t6 * t20;   
  t25 = 0.10000000000000000e1 + 0.9008261918853394e1 * r->rs + 0.3332002091228748e1 * t2 + 0.9437167005710024e-1 * t4;   
  r->dfdrs = -t17 * t13 + t21 * t25;   
   
  if(r->order < 2) return;   
   
  t28 = 0.14811103470714106e1 + 0.11809367271707988e0 * r->rs;   
  t30 = t17 * t20;   
  t34 = 0.1e1 / t19 / t12;   
  t35 = t6 * t34;   
  t36 = t25 * t25;   
  t41 = 0.9008261918853394e1 + 0.6664004182457496e1 * r->rs + 0.28311501017130072e0 * t2;   
  r->d2fdrs2 = -t28 * t13 + t21 * t41 + 0.2e1 * t30 * t25 - 0.2e1 * t35 * t36;   
   
  if(r->order < 3) return;   
   
  t52 = t19 * t19;   
  r->d3fdrs3 = -0.11809367271707988e0 * t13 + 0.3e1 * t28 * t20 * t25 - 0.6e1 * t17 * t34 * t36 + 0.3e1 * t30 * t41 + 0.6e1 * t6 / t52 * t36 * t25 - 0.6e1 * t35 * t25 * t41 + t21 * (0.6664004182457496e1 + 0.56623002034260144e0 * r->rs);   
   
  if(r->order < 4) return;   
   
   
}   
   
#ifdef DEVICE   
__device__ static void   
xc_lda_xc_teter93_func1_kernel(const void *p, xc_lda_work_t *r)   
#else   
static void   
func1(const xc_func_type *p, xc_lda_work_t *r)   
#endif   
{   
  double t1, t2, t4, t5, t8, t11, t12, t14;   
  double t18, t19, t22, t23, t25, t28, t31, t34;   
  double t35, t37, t38, t44, t46, t47, t48, t55;   
  double t59, t61, t63, t65, t67, t73, t78, t80;   
  double t84, t85, t86, t94, t99, t102, t104, t110;   
  double t112, t114, t118, t120, t122, t124, t126, t130;   
  double t137, t142, t145, t150, t152, t169, t176, t204;   
  double t230, t234, t236;   
   
   
  t1 = 0.1e1 + r->z;   
  t2 = cbrt(t1);   
  t4 = 0.1e1 - r->z;   
  t5 = cbrt(t4);   
  t8 = M_CBRT2;   
  t11 = 0.1e1 / (0.2e1 * t8 - 0.2e1);   
  t12 = (t2 * t1 + t5 * t4 - 0.2e1) * t11;   
  t14 = 0.6157402568883345e0 * t12;   
  t18 = 0.7405551735357053e0 + 0.1574201515892867e0 * t12;   
  t19 = r->rs * r->rs;   
  t22 = 0.1968227878617998e-1 + 0.3532336663397157e-2 * t12;   
  t23 = t19 * r->rs;   
  t25 = 0.4581652932831429e0 + 0.119086804055547e0 * t12 + (0.2217058676663745e1 + t14) * r->rs + t18 * t19 + t22 * t23;   
  t28 = 0.4504130959426697e1 + 0.2673612973836267e0 * t12;   
  t31 = 0.1110667363742916e1 + 0.2052004607777787e0 * t12;   
  t34 = 0.2359291751427506e-1 + 0.4200005045691381e-2 * t12;   
  t35 = t19 * t19;   
  t37 = 0.10000000000000000e1 * r->rs + t28 * t19 + t31 * t23 + t34 * t35;   
  t38 = 0.1e1 / t37;   
  r->f = -t25 * t38;   
   
  if(r->order < 1) return;   
   
  t44 = 0.2217058676663745e1 + t14 + 0.2e1 * t18 * r->rs + 0.3e1 * t22 * t19;   
  t46 = t37 * t37;   
  t47 = 0.1e1 / t46;   
  t48 = t25 * t47;   
  t55 = 0.10000000000000000e1 + 0.2e1 * t28 * r->rs + 0.3e1 * t31 * t19 + 0.4e1 * t34 * t23;   
  r->dfdrs = -t44 * t38 + t48 * t55;   
  t59 = (0.4e1 / 0.3e1 * t2 - 0.4e1 / 0.3e1 * t5) * t11;   
  t61 = t59 * r->rs;   
  t63 = t59 * t19;   
  t65 = t59 * t23;   
  t67 = 0.119086804055547e0 * t59 + 0.6157402568883345e0 * t61 + 0.1574201515892867e0 * t63 + 0.3532336663397157e-2 * t65;   
  t73 = 0.2673612973836267e0 * t63 + 0.2052004607777787e0 * t65 + 0.4200005045691381e-2 * t59 * t35;   
  r->dfdz = -t67 * t38 + t48 * t73;   
   
  if(r->order < 2) return;   
   
  t78 = 0.14811103470714106e1 + 0.3148403031785734e0 * t12 + 0.6e1 * t22 * r->rs;   
  t80 = t44 * t47;   
  t84 = 0.1e1 / t46 / t37;   
  t85 = t25 * t84;   
  t86 = t55 * t55;   
  t94 = 0.9008261918853394e1 + 0.5347225947672534e0 * t12 + 0.6e1 * t31 * r->rs + 0.12e2 * t34 * t19;   
  r->d2fdrs2 = -t78 * t38 + t48 * t94 + 0.2e1 * t80 * t55 - 0.2e1 * t85 * t86;   
  t99 = 0.6157402568883345e0 * t59 + 0.3148403031785734e0 * t61 + 0.10597009990191471e-1 * t63;   
  t102 = t67 * t47;   
  t104 = t55 * t73;   
  t110 = 0.5347225947672534e0 * t61 + 0.6156013823333361e0 * t63 + 0.16800020182765524e-1 * t65;   
  r->d2fdrsz = t102 * t55 - 0.2e1 * t85 * t104 + t48 * t110 - t99 * t38 + t80 * t73;   
  t112 = t2 * t2;   
  t114 = t5 * t5;   
  t118 = (0.4e1 / 0.9e1 / t112 + 0.4e1 / 0.9e1 / t114) * t11;   
  t120 = t118 * r->rs;   
  t122 = t118 * t19;   
  t124 = t118 * t23;   
  t126 = 0.119086804055547e0 * t118 + 0.6157402568883345e0 * t120 + 0.1574201515892867e0 * t122 + 0.3532336663397157e-2 * t124;   
  t130 = t73 * t73;   
  t137 = 0.2673612973836267e0 * t122 + 0.2052004607777787e0 * t124 + 0.4200005045691381e-2 * t118 * t35;   
  r->d2fdz2 = 0.2e1 * t102 * t73 - t126 * t38 - 0.2e1 * t85 * t130 + t48 * t137;   
   
  if(r->order < 3) return;   
   
  t142 = t78 * t47;   
  t145 = t44 * t84;   
  t150 = t46 * t46;   
  t152 = t25 / t150;   
  r->d3fdrs3 = -(0.11809367271707988e0 + 0.21194019980382942e-1 * t12) * t38 + 0.3e1 * t142 * t55 - 0.6e1 * t145 * t86 + 0.3e1 * t80 * t94 + 0.6e1 * t152 * t86 * t55 - 0.6e1 * t85 * t55 * t94 + t48 * (0.6664004182457496e1 + 0.12312027646666722e1 * t12 + 0.24e2 * t34 * r->rs);   
  t169 = t99 * t47;   
  t176 = t67 * t84;   
  r->d3fdrs2z = -(0.3148403031785734e0 * t59 + 0.21194019980382942e-1 * t61) * t38 + t142 * t73 + 0.2e1 * t169 * t55 - 0.4e1 * t145 * t104 + 0.2e1 * t80 * t110 - 0.2e1 * t176 * t86 + 0.6e1 * t152 * t86 * t73 - 0.4e1 * t85 * t55 * t110 + t102 * t94 - 0.2e1 * t85 * t94 * t73 + t48 * (0.5347225947672534e0 * t59 + 0.12312027646666722e1 * t61 + 0.50400060548296572e-1 * t63);   
  t204 = t126 * t47;   
  r->d3fdrsz2 = -(0.6157402568883345e0 * t118 + 0.3148403031785734e0 * t120 + 0.10597009990191471e-1 * t122) * t38 + 0.2e1 * t169 * t73 - 0.2e1 * t145 * t130 + t80 * t137 + t204 * t55 - 0.4e1 * t176 * t104 + 0.2e1 * t102 * t110 + 0.6e1 * t152 * t55 * t130 - 0.4e1 * t85 * t110 * t73 - 0.2e1 * t85 * t55 * t137 + t48 * (0.5347225947672534e0 * t120 + 0.6156013823333361e0 * t122 + 0.16800020182765524e-1 * t124);   
  t230 = (-0.8e1 / 0.27e2 / t112 / t1 + 0.8e1 / 0.27e2 / t114 / t4) * t11;   
  t234 = t230 * t19;   
  t236 = t230 * t23;   
  r->d3fdz3 = -(0.119086804055547e0 * t230 + 0.6157402568883345e0 * t230 * r->rs + 0.1574201515892867e0 * t234 + 0.3532336663397157e-2 * t236) * t38 + 0.3e1 * t204 * t73 - 0.6e1 * t176 * t130 + 0.3e1 * t102 * t137 + 0.6e1 * t152 * t130 * t73 - 0.6e1 * t85 * t73 * t137 + t48 * (0.2673612973836267e0 * t234 + 0.2052004607777787e0 * t236 + 0.4200005045691381e-2 * t230 * t35);   
   
  if(r->order < 4) return;   
   
   
}   
   
#ifdef DEVICE   
__device__ void   
xc_lda_xc_teter93_func_kernel(const void *p, xc_lda_work_t *r)   
{   
  if(r->nspin == XC_UNPOLARIZED)   
xc_lda_xc_teter93_func0_kernel(p, r);   
  else   
xc_lda_xc_teter93_func1_kernel(p, r);   
}   
#else   
void    
xc_lda_xc_teter93_func(const xc_func_type *p, xc_lda_work_t *r)   
{   
  if(p->nspin == XC_UNPOLARIZED)   
    func0(p, r);   
  else   
    func1(p, r);   
}   
#endif   
   
#ifndef DEVICE   
#define maple2c_order 3   
#define maple2c_func  xc_lda_xc_teter93_func   
#define kernel_id 27 
#endif
