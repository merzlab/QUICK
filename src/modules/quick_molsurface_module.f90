#include "util.fh"
!---------------------------------------------------------------------!
! Created by Vikrant Tripathy on   10/05/2024                         !
!                                                                     ! 
! Copyright (C) 2024-2025 Götz lab                                    !
!                                                                     !
! This Source Code Form is subject to the terms of the Mozilla Public !
! License, v. 2.0. If a copy of the MPL was not distributed with this !
! file, You can obtain one at http://mozilla.org/MPL/2.0/.            !
!_____________________________________________________________________!

!-----------------------------------------------------------------------------------!
! This module contains subroutines related to generating molecular surfaces         !
! These molecular surfaces are used to evaluate ESP, EFIELD, and other properties.  ! 
!--------------------------------------------------------------------------------- -!

module quick_molsurface_module

  implicit none
  private

  public :: generate_MKS_surfaces

  contains

!  atomic_symbols = [
!  "H",                                                                                                 "He",
! "Li", "Be",                                                              "B",  "C",  "N",  "O",  "F", "Ne",
! "Na", "Mg",                                                             "Al", "Si",  "P",  "S", "Cl", "Ar",
!  "K", "Ca", "Sc", "Ti",  "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr",
! "Rb", "Sr",  "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te",  "I", "Xe",
! "Cs", "Ba", "La", "Hf", "Ta",  "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rd",
! "Fr", "Ra", "Ac", "Rf", "Db", "Sg", "Bh", "Bh", "Mt", "Ds", "Rg", "Cn"  "Nh", "Fl", "Mc", "Lv", "Ts", "Og",
!  
!  "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu",
!  "Th", "Pa",  "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr",
! ]

! Bondi_vdw_radii (J. Phys. Chem. 1964, 68, 3, 441–451) = [ 
! 1.20,                                                                                                  1.40,
! 1.82,   --,                                                                --, 1.70, 1.55, 1.52, 1.47, 1.54,
! 2.27, 1.73,                                                                --, 2.10, 1.80, 1.80, 1.75, 1.88,
! 2.75,   --,   --,   --,   --,   --,   --,   --,   --,  1.63, 1.40, 1.39, 1.87,   --, 1.85, 1.90, 1.85, 2.02,
!   --,   --,   --,   --,   --,   --,   --,   --,   --,  1.63, 1.72, 1.58, 1.93, 2.17,   --, 2.06, 1.98, 2.16,
!   --,   --,   --,   --,   --,   --,   --,   --,   --,  1.75, 1.66, 1.55, 1.96, 2.02,   --,   --,   --,   --,
!   --,   --,   --,   --,   --,   --,   --,   --,   --,    --,   --,   --,   --,   --,   --,   --,   --,   --,
!
!   --,   --,   --,   --,   --,   --,   --,   --,   --,  --,   --,   --,   --,   --,
!   --,   --, 1.86,   --,   --,   --,   --,   --,   --,  --,   --,   --,   --,   --,
! ]

! Tkatchenko_vdw_radii (J. Chem. Theory Comput. 2024, 20, 17, 7469–7478) = [ 
! 1.67,                                                                                                  1.41,
! 2.80, 2.27,                                                              2.08, 1.91, 1.80, 1.71, 1.63, 1.55,
! 2.80, 2.48,                                                              2.41, 2.27, 2.14, 2.06, 1.98, 1.91,
! 3.04, 2.79, 2.60, 2.61, 2.56, 2.54, 2.47, 2.44, 2.39,  2.36, 2.34, 2.28, 2.36, 2.29, 2.20, 2.19, 2.09, 2.02,
! 3.08, 2.87, 2.79, 2.65, 2.60, 2.56, 2.52, 2.49, 2.46,  2.15, 2.39, 2.33, 2.45, 2.38, 2.31, 2.27, 2.23, 2.17,
! 3.18, 3.01, 2.91, 2.62, 2.50, 2.47, 2.44, 2.41, 2.39,  2.35, 2.25, 2.23, 2.36, 2.34, 2.35, 2.32, 2.30, 2.24,
! 3.08, 2.97, 2.89, 2.65, 2.30, 2.29, 2.27, 2.25, 2.24,  2.22, 2.22, 2.17, 2.19, 2.21, 2.48,   --, 2.51, 2.41,
!
! 2.89, 2.91, 2.90, 2.88, 2.86, 2.85, 2.78, 2.81, 2.80, 2.78, 2.76, 2.75, 2.73, 2.73,
! 2.92, 2.77, 2.70, 2.77, 2.71, 2.71, 2.75, 2.69, 2.68, 2.67, 2.66, 2.64, 2.64, 3.08,
! ]

!----------------------------------------------------------------------------!
! This subroutine generates the MKS surfaces for the molecule                !
! The MKS surfaces are generated by scaling the vdW surface by a factor of c !
! where c = {1.4, 1.6, 1.8, 2.0}                                             !
! The MKS surfaces are used to evaluate ESP, EFIELD, and other properties    !
!----------------------------------------------------------------------------!

  subroutine generate_MKS_surfaces()
    use quick_molspec_module, only: natom, quick_molspec
    use quick_method_module, only: quick_method
    use quick_files_module, only: iVdwSurfFile, VdwSurfFileName
    use quick_exception_module, only: RaiseException
    use quick_constants_module, only: BOHRS_TO_A
    use quick_timer_module, only : timer_begin, timer_end, timer_cumer

    implicit none

    double precision :: surface_points(3,int(natom*500/quick_method%espgrid_spacing))
    double precision :: scaling_factors(4)
    data scaling_factors/1.4d0,1.6d0,1.8d0,2.0d0/
    integer :: npoints, total_points
    integer :: i, j, k, ierr
    integer :: max_points
    double precision, allocatable :: xyz_points(:,:)

    RECORD_TIME(timer_begin%TESPsurface)

    max_points = int(natom*200/(quick_method%espgrid_spacing)**2)

    allocate(xyz_points(3,max_points))

      ierr = 0

      total_points = 0

      do j = 1, 4
        ! Generate the vdW surface using different scaling factors for vdw radii
        call generate_vdW_surface(scaling_factors(j),npoints,surface_points)

        total_points = total_points + npoints

        if(total_points .gt. max_points) then
          ierr = 41
          call RaiseException(ierr)
        end if

          do k = 1,3
             xyz_points(1:3,total_points-npoints+1:total_points) = surface_points(1:3,1:npoints)
        end do

      end do

      quick_molspec%nvdwpoint = total_points
      allocate(quick_molspec%vdwpointxyz(3,quick_molspec%nvdwpoint))
      quick_molspec%vdwpointxyz(1:3,1:total_points) = xyz_points(1:3,1:total_points)

      deallocate(xyz_points)

      RECORD_TIME(timer_end%TESPsurface)
      timer_cumer%TESPsurface=timer_cumer%TESPsurface+timer_end%TESPsurface-timer_begin%TESPsurface

   end subroutine generate_MKS_surfaces

  subroutine generate_vdW_surface(scale_factor,npoints,surface_points)
    use quick_method_module, only: quick_method
    use quick_molspec_module, only: quick_molspec, natom, xyz
    use quick_constants_module, only: PI, BOHRS_TO_A
    use quick_exception_module, only: RaiseException
    use quick_constants_module, only : symbol

    implicit none

    double precision, external :: rootSquare

    integer, intent(out) :: npoints
    integer :: i,j,k,ncircles,circle,npts,nphi
    double precision :: scale_factor,espgrid_spacing
    double precision :: start_theta,delta_theta,rcircle,radius,theta,delta_phi
    double precision :: Bondi_vdw_radii(118), Tkatchenko_vdw_radii(118)
    integer :: Bondi_atom_list(38)
    double precision :: atomic_vdw_radii(natom),xyz_sphere(3,4000)
    double precision, intent(out) :: surface_points(3,natom*2000)
    double precision :: thresh
    logical :: proximal
    data Bondi_vdw_radii/ &
    1.20d0,                                                                                                                1.40d0, &
    1.82d0, 0.0d0,                                                                       0.0d0,1.70d0,1.55d0,1.52d0,1.47d0,1.54d0, &
    2.27d0,1.73d0,                                                                       0.0d0,2.10d0,1.80d0,1.80d0,1.75d0,1.88d0, &
    2.75d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0,1.63d0,1.40d0,1.39d0,1.87d0, 0.0d0,1.85d0,1.90d0,1.85d0,2.02d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0,1.63d0,1.72d0,1.58d0,1.93d0,2.17d0, 0.0d0,2.06d0,1.98d0,2.16d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0,1.75d0,1.66d0,1.55d0,1.96d0,2.02d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, &
     0.0d0,1.86d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/
    data Tkatchenko_vdw_radii/ &
    1.67d0,                                                                                                                1.41d0, &
    2.80d0,2.27d0,                                                                      2.08d0,1.91d0,1.80d0,1.71d0,1.63d0,1.55d0, &
    2.80d0,2.48d0,                                                                      2.41d0,2.27d0,2.14d0,2.06d0,1.98d0,1.91d0, &
    3.04d0,2.79d0,2.60d0,2.61d0,2.56d0,2.54d0,2.47d0,2.44d0,2.39d0,2.36d0,2.34d0,2.28d0,2.36d0,2.29d0,2.20d0,2.19d0,2.09d0,2.02d0, &
    3.08d0,2.87d0,2.79d0,2.65d0,2.60d0,2.56d0,2.52d0,2.49d0,2.46d0,2.15d0,2.39d0,2.33d0,2.45d0,2.38d0,2.31d0,2.27d0,2.23d0,2.17d0, &
    3.18d0,3.01d0,2.91d0,2.89d0,2.91d0,2.90d0,2.88d0,2.86d0,2.85d0,2.78d0,2.81d0,2.80d0,2.78d0,2.76d0,2.75d0,2.73d0,2.73d0,2.62d0, &
    2.50d0,2.47d0,2.44d0,2.41d0,2.39d0,2.35d0,2.25d0,2.23d0,2.36d0,2.34d0,2.35d0,2.32d0,2.30d0,2.24d0,3.08d0,2.97d0,2.89d0,2.92d0, &
    2.77d0,2.70d0,2.77d0,2.71d0,2.71d0,2.75d0,2.69d0,2.68d0,2.67d0,2.66d0,2.64d0,2.64d0,3.08d0,2.65d0,2.30d0,2.29d0,2.27d0,2.25d0, &
    2.24d0,2.22d0,2.22d0,2.17d0,2.19d0,2.21d0,2.48d0,0.0d0,2.51d0,2.41d0/
    data Bondi_atom_list/1,2,3,6,7,8,9,10,11,12,14,15,16,17,18,19,28,29,30,31,33,34,35,36,46,47,48,49,50,52,53,54,78,79,80,81,82,92/

    ! grid size must be converted to atomic unit
    espgrid_spacing = quick_method%espgrid_spacing/BOHRS_TO_A

    ! this threshold is necessary to avoid points on surface coming too close
    ! points being too close leads has the artifact of those points having
    ! larger weight during fitting. We try to avoid this.
    thresh = espgrid_spacing/2.5

    !  create an array of vanderwaals radii for atom. The radii are in atomic units.
    if (quick_method%vdw_radii == "BONDI")then
      do i = 1, natom
        ! checking if every atom has a corresponding Van der waals radius defined
        if (any(int(quick_molspec%chg(i)) == Bondi_atom_list)) then 
          atomic_vdw_radii(i) = Bondi_vdw_radii(int(quick_molspec%chg(i)))*scale_factor/BOHRS_TO_A
        else
          do j = 1, natom
            if (.not. any(int(quick_molspec%chg(j)) == Bondi_atom_list)) then
              call PrtErr(OUTFILEHANDLE, symbol(quick_molspec%iattype(j))//" does not have available Bondi Van Der Waals radius.")
            end if
          end do
          call PrtErr(OUTFILEHANDLE, 'Please use the keyword vdw_radii=TC to avoid this.')
          call quick_exit(OUTFILEHANDLE,1)
        endif
      end do
    else if (quick_method%vdw_radii == "TC")then
      do i = 1, natom
        ! Tkatchenko_vdw_radii does not have the data for Lv
        if (int(quick_molspec%chg(i)) /= 116) then
          atomic_vdw_radii(i) = Tkatchenko_vdw_radii(int(quick_molspec%chg(i)))*scale_factor/BOHRS_TO_A
        else
          call PrtErr(OUTFILEHANDLE, 'The Van Der Waals radius of the element Lv is not available')
          call quick_exit(OUTFILEHANDLE,1)
        endif
      end do
    endif

    npoints = 0

    ! Go over each atom and get points on their vanderwaals surface using 
    ! the correspnding atomic_vdw_radii
    do i = 1, natom
      npts = 0
      radius = atomic_vdw_radii(i)
      ! We will make circles on the surface. Find the number of circles to make.
      ncircles = int(PI*radius/espgrid_spacing)+1
      start_theta = (PI*radius-(ncircles-1)*espgrid_spacing)/(2*radius)
      delta_theta = espgrid_spacing/radius
      do circle = 1, ncircles
        theta = start_theta+delta_theta*(circle-1)
        rcircle = radius*sin(theta)
        nphi = int(2*PI*rcircle/espgrid_spacing)
        delta_phi = espgrid_spacing/rcircle
        do j = 1, nphi
          npts = npts + 1
          xyz_sphere(1,npts) = xyz(1,i) + radius*cos(theta)
          xyz_sphere(2,npts) = xyz(2,i) + radius*sin(theta)*cos((j-1)*delta_phi)
          xyz_sphere(3,npts) = xyz(3,i) + radius*sin(theta)*sin((j-1)*delta_phi)
          do k = 1, natom
            if (k .ne. i)then
              if(rootSquare(xyz_sphere(1:3,npts),xyz(1:3,k),3).lt.atomic_vdw_radii(k))then
                npts = npts - 1
                exit
              end if
            end if
          end do
        end do
      end do

      if (npoints.eq.0)then
        do j = 1, npts
          do k = 1, 3
            surface_points(k,j) = xyz_sphere(k,j)
          end do
        end do
        npoints = npts
      else
        do j = 1, npts
          proximal = .False.
          do k = 1, npoints
            if (rootSquare(surface_points(1:3,k), xyz_sphere(1:3,j), 3).lt.thresh)then
              proximal = .True.
              exit
            end if
          end do
          if (.not. proximal) then
            npoints = npoints + 1
            do k = 1,3
              surface_points(k,npoints) = xyz_sphere(k,j)
            end do
          end if
        end do
      end if
    end do

  end subroutine generate_vdW_surface

end module quick_molsurface_module
