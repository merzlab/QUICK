#include "util.fh"
!---------------------------------------------------------------------!
! Created by Vikrant Tripathy on   10/05/2024                         !
!                                                                     ! 
! Copyright (C) 2024-2025 Götz lab                                    !
!                                                                     !
! This Source Code Form is subject to the terms of the Mozilla Public !
! License, v. 2.0. If a copy of the MPL was not distributed with this !
! file, You can obtain one at http://mozilla.org/MPL/2.0/.            !
!_____________________________________________________________________!

!-----------------------------------------------------------------------------------!
! This module contains subroutines related to generating molecular surfaces         !
! These molecular surfaces are used to evaluate ESP, EFIELD, and other properties.  ! 
!--------------------------------------------------------------------------------- -!

module quick_molsurface_module

  implicit none
  private

  public :: generate_MKS_surfaces

  contains

!  atomic_symbols = [
!  "H",                                                                                                 "He",
! "Li", "Be",                                                              "B",  "C",  "N",  "O",  "F", "Ne",
! "Na", "Mg",                                                             "Al", "Si",  "P",  "S", "Cl", "Ar",
!  "K", "Ca", "Sc", "Ti",  "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr",
! "Rb", "Sr",  "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te",  "I", "Xe",
! "Cs", "Ba", "La", "Hf", "Ta",  "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rd",
! "Fr", "Ra", "Ac", "Rf", "Db", "Sg", "Bh", "Bh", "Mt", "Ds", "Rg", "Cn"  "Nh", "Fl", "Mc", "Lv", "Ts", "Og",
!  
!  "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu",
!  "Th", "Pa",  "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr",
! ]

! Bondi_vdw_radii (J. Phys. Chem. 1964, 68, 3, 441–451) = [ 
! 1.20,                                                                                                  1.40,
! 1.82,   --,                                                                --, 1.70, 1.55, 1.52, 1.47, 1.54,
! 2.27, 1.73,                                                                --, 2.10, 1.80, 1.80, 1.75, 1.88,
! 2.75,   --,   --,   --,   --,   --,   --,   --,   --,  1.63, 1.40, 1.39, 1.87,   --, 1.85, 1.90, 1.85, 2.02,
!   --,   --,   --,   --,   --,   --,   --,   --,   --,  1.63, 1.72, 1.58, 1.93, 2.17,   --, 2.06, 1.98, 2.16,
!   --,   --,   --,   --,   --,   --,   --,   --,   --,  1.75, 1.66, 1.55, 1.96, 2.02,   --,   --,   --,   --,
!   --,   --,   --,   --,   --,   --,   --,   --,   --,    --,   --,   --,   --,   --,   --,   --,   --,   --,
!
!   --,   --,   --,   --,   --,   --,   --,   --,   --,  --,   --,   --,   --,   --,
!   --,   --, 1.86,   --,   --,   --,   --,   --,   --,  --,   --,   --,   --,   --,
! ]

! Tkatchenko_vdw_radii (J. Chem. Theory Comput. 2024, 20, 17, 7469–7478) = [ 
! 1.67,                                                                                                  1.41,
! 2.80, 2.27,                                                              2.08, 1.91, 1.80, 1.71, 1.63, 1.55,
! 2.80, 2.48,                                                              2.41, 2.27, 2.14, 2.06, 1.98, 1.91,
! 3.04, 2.79, 2.60, 2.61, 2.56, 2.54, 2.47, 2.44, 2.39,  2.36, 2.34, 2.28, 2.36, 2.29, 2.20, 2.19, 2.09, 2.02,
! 3.08, 2.87, 2.79, 2.65, 2.60, 2.56, 2.52, 2.49, 2.46,  2.15, 2.39, 2.33, 2.45, 2.38, 2.31, 2.27, 2.23, 2.17,
! 3.18, 3.01, 2.91, 2.62, 2.50, 2.47, 2.44, 2.41, 2.39,  2.35, 2.25, 2.23, 2.36, 2.34, 2.35, 2.32, 2.30, 2.24,
! 3.08, 2.97, 2.89, 2.65, 2.30, 2.29, 2.27, 2.25, 2.24,  2.22, 2.22, 2.17, 2.19, 2.21, 2.48,   --, 2.51, 2.41,
!
! 2.89, 2.91, 2.90, 2.88, 2.86, 2.85, 2.78, 2.81, 2.80, 2.78, 2.76, 2.75, 2.73, 2.73,
! 2.92, 2.77, 2.70, 2.77, 2.71, 2.71, 2.75, 2.69, 2.68, 2.67, 2.66, 2.64, 2.64, 3.08,
! ]

!----------------------------------------------------------------------------!
! This subroutine generates the MKS surfaces for the molecule                !
! The MKS surfaces are generated by scaling the vdW surface by a factor of c !
! where c = {1.4, 1.6, 1.8, 2.0}                                             !
! The MKS surfaces are used to evaluate ESP, EFIELD, and other properties    !
!----------------------------------------------------------------------------!

  subroutine generate_MKS_surfaces()
    use quick_molspec_module, only: natom, quick_molspec
    use quick_method_module, only: quick_method
    use quick_files_module, only: iVdwSurfFile, VdwSurfFileName
    use quick_exception_module, only: RaiseException
    use quick_constants_module, only: BOHRS_TO_A
    use quick_timer_module, only : timer_begin, timer_end, timer_cumer

    implicit none

    double precision,allocatable :: surface_points(:,:)
    double precision :: scaling_factors(4)
    data scaling_factors/1.4d0,1.6d0,1.8d0,2.0d0/
    integer :: npoints, total_points
    integer :: i, j
    integer :: max_points
    double precision, allocatable :: xyz_points(:,:), temp(:,:)

    ! Record time needed to create the grid.
    RECORD_TIME(timer_begin%TESPsurface)
    ! Maximum no of points including all the four surfaces.
    ! This is being reallocated when later when required.
    ! Segmentation fault will not arise from xyz_points array overflow.
    max_points = int(natom*200/(quick_method%espgrid_spacing)**2)
    allocate(xyz_points(3,max_points))
    ! This is the maximum no of points on the individual van der waals surfaces.
    ! This is the biggest bottleneck in going to extremely fine grids as I do not
    ! know how to reallocate this in the generate_vdW_surface subroutine.
    allocate(surface_points(3,int(natom*1000/quick_method%espgrid_spacing)))
    ! Initialize total_points to keep track of how many points are in the van der waals surfaces.
    total_points = 0
    ! Loop to generate 4 van der waals surfaces.
    do j = 1, 4
      ! Generate the vdW surface using different scaling factors for vdw radii
      call generate_vdW_surface(scaling_factors(j),npoints,surface_points)
      ! After individual van der waals surface is generated the total no of points
      ! is updated.
      total_points = total_points + npoints
      ! If the no of points is exceeding the allocated xyz_points array size reallocation is required.
      if(total_points .gt. max_points) then
        ! temporary array to facilitate reallocation
        allocate(temp(3,total_points-npoints))
        ! Move the contents of xyz_points to a temporary array
        temp = xyz_points(1:3,1:total_points-npoints)
        ! Now we can deallocate the xyz_points array
        deallocate(xyz_points)
        ! Reallocation size depends on when and by how much the no of points exceeded the size of
        ! previous allocation.
        if((j.eq.4).or.(total_points .gt. 2*max_points))then
          allocate(xyz_points(3,total_points))
        else
          max_points = 2*max_points
          allocate(xyz_points(3,max_points))
        endif
        ! We are ready to move the data from temporary array back to xyz_points
        xyz_points(1:3,1:total_points-npoints) = temp
        ! The temporary array is deallocated
        deallocate(temp)
      end if
      ! Copy the data from array containing individual van der waals surafce to the xyz_points array
      ! containing all the points.
      xyz_points(1:3,total_points-npoints+1:total_points) = surface_points(1:3,1:npoints)
    end do
    ! Deallocate surface_points as you do not need this array anymore
    deallocate(surface_points)
    ! We need the quick_molspec%nvdwpoint elsewhere to compute ESP on those points. So, we should
    ! assign correct value to it.
    quick_molspec%nvdwpoint = total_points
    ! We also need quick_molspec%vdwpointxyz elsewhere to compute ESP on those points. So, we are
    ! allocating it and copying the all the points to it.
    allocate(quick_molspec%vdwpointxyz(3,quick_molspec%nvdwpoint))
    quick_molspec%vdwpointxyz(1:3,1:total_points) = xyz_points(1:3,1:total_points)
    ! deallocated the array required to create the grid.
    deallocate(xyz_points)
    ! Record time needed to create the grid.
    RECORD_TIME(timer_end%TESPsurface)
    timer_cumer%TESPsurface=timer_cumer%TESPsurface+timer_end%TESPsurface-timer_begin%TESPsurface
   end subroutine generate_MKS_surfaces

  ! This subroutine generates the individual scaled van der waals surfaces  
  subroutine generate_vdW_surface(scale_factor,npoints,surface_points)
    use quick_method_module, only: quick_method
    use quick_molspec_module, only: quick_molspec, natom, xyz
    use quick_constants_module, only: PI, BOHRS_TO_A
    use quick_exception_module, only: RaiseException
    use quick_constants_module, only : symbol

    implicit none

    double precision, external :: rootSquare

    integer, intent(out) :: npoints
    integer :: i,j,k,l,ii,ncircles,circle,npts,nphi,nneighbor
    double precision, intent(in) :: scale_factor
    double precision :: espgrid_spacing
    double precision :: start_theta,delta_theta,rcircle,radius,theta,delta_phi
    double precision :: Bondi_vdw_radii(118), Tkatchenko_vdw_radii(118)
    integer :: Bondi_atom_list(38)
    integer :: neighbor_list(natom), start_index(natom), end_index(natom)
    double precision :: atomic_vdw_radii(natom), xyz_sphere(3,4000)
    double precision, intent(out) :: surface_points(:,:)
    double precision :: thresh
    logical :: proximal
    data Bondi_vdw_radii/ &
    1.20d0,                                                                                                                1.40d0, &
    1.82d0, 0.0d0,                                                                       0.0d0,1.70d0,1.55d0,1.52d0,1.47d0,1.54d0, &
    2.27d0,1.73d0,                                                                       0.0d0,2.10d0,1.80d0,1.80d0,1.75d0,1.88d0, &
    2.75d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0,1.63d0,1.40d0,1.39d0,1.87d0, 0.0d0,1.85d0,1.90d0,1.85d0,2.02d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0,1.63d0,1.72d0,1.58d0,1.93d0,2.17d0, 0.0d0,2.06d0,1.98d0,2.16d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0,1.75d0,1.66d0,1.55d0,1.96d0,2.02d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, &
     0.0d0,1.86d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, &
     0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0, 0.0d0/
    data Tkatchenko_vdw_radii/ &
    1.67d0,                                                                                                                1.41d0, &
    2.80d0,2.27d0,                                                                      2.08d0,1.91d0,1.80d0,1.71d0,1.63d0,1.55d0, &
    2.80d0,2.48d0,                                                                      2.41d0,2.27d0,2.14d0,2.06d0,1.98d0,1.91d0, &
    3.04d0,2.79d0,2.60d0,2.61d0,2.56d0,2.54d0,2.47d0,2.44d0,2.39d0,2.36d0,2.34d0,2.28d0,2.36d0,2.29d0,2.20d0,2.19d0,2.09d0,2.02d0, &
    3.08d0,2.87d0,2.79d0,2.65d0,2.60d0,2.56d0,2.52d0,2.49d0,2.46d0,2.15d0,2.39d0,2.33d0,2.45d0,2.38d0,2.31d0,2.27d0,2.23d0,2.17d0, &
    3.18d0,3.01d0,2.91d0,2.89d0,2.91d0,2.90d0,2.88d0,2.86d0,2.85d0,2.78d0,2.81d0,2.80d0,2.78d0,2.76d0,2.75d0,2.73d0,2.73d0,2.62d0, &
    2.50d0,2.47d0,2.44d0,2.41d0,2.39d0,2.35d0,2.25d0,2.23d0,2.36d0,2.34d0,2.35d0,2.32d0,2.30d0,2.24d0,3.08d0,2.97d0,2.89d0,2.92d0, &
    2.77d0,2.70d0,2.77d0,2.71d0,2.71d0,2.75d0,2.69d0,2.68d0,2.67d0,2.66d0,2.64d0,2.64d0,3.08d0,2.65d0,2.30d0,2.29d0,2.27d0,2.25d0, &
    2.24d0,2.22d0,2.22d0,2.17d0,2.19d0,2.21d0,2.48d0,0.0d0,2.51d0,2.41d0/
    data Bondi_atom_list/1,2,3,6,7,8,9,10,11,12,14,15,16,17,18,19,28,29,30,31,33,34,35,36,46,47,48,49,50,52,53,54,78,79,80,81,82,92/

    ! grid size must be converted to atomic unit
    espgrid_spacing = quick_method%espgrid_spacing/BOHRS_TO_A
    ! this threshold is necessary to avoid points on surface coming too close
    ! points being too close leads has the artifact of those points having
    ! larger weight during fitting. We try to avoid this.
    thresh = espgrid_spacing/2.5
    !  create an array of vanderwaals radii for atom. The radii are in atomic units.
    if (quick_method%vdw_radii == "BONDI")then
      do i = 1, natom
        ! checking if every atom has a corresponding Van der waals radius defined
        if (any(int(quick_molspec%chg(i)) == Bondi_atom_list)) then 
          ! Here we scale the van der waals radius of the atom using the scale_factor
          atomic_vdw_radii(i) = Bondi_vdw_radii(int(quick_molspec%chg(i)))*scale_factor/BOHRS_TO_A
        else
          do j = 1, natom
            if (.not. any(int(quick_molspec%chg(j)) == Bondi_atom_list)) then
              call PrtErr(OUTFILEHANDLE, symbol(quick_molspec%iattype(j))//" does not have available Bondi Van Der Waals radius.")
            end if
          end do
          call PrtErr(OUTFILEHANDLE, 'Please use the keyword vdw_radii=TC to avoid this.')
          call quick_exit(OUTFILEHANDLE,1)
        endif
      end do
    else if (quick_method%vdw_radii == "TC")then
      do i = 1, natom
        ! Tkatchenko_vdw_radii does not have the data for Lv
        if (int(quick_molspec%chg(i)) /= 116) then
          ! Here we scale the van der waals radius of the atom using the scale_factor
          atomic_vdw_radii(i) = Tkatchenko_vdw_radii(int(quick_molspec%chg(i)))*scale_factor/BOHRS_TO_A
        else
          call PrtErr(OUTFILEHANDLE, 'The Van Der Waals radius of the element Lv is not available')
          call quick_exit(OUTFILEHANDLE,1)
        endif
      end do
    endif
    ! Initialize the counter for points on this scaled van der waals surface
    npoints = 0
    ! Initialize the variable to be used for detection of overlapping points later
    proximal = .False.
    ! Go over each atom and get points on their vanderwaals surface using 
    ! the correspnding atomic_vdw_radii
    do i = 1, natom
      ! Create a list of neighbors for efficiency
      ! Initialize the no of neighbors
      nneighbor=0
      ! loop over all the atoms
      do ii = 1, natom
        ! do not consider the same atom as its own neighbor
        if (ii .ne. i) then
          ! Using sum of van der waals radii as the criterium for neighbors. A threshold is added to check
          ! overlapping points(vide infra).
          if(rootSquare(xyz(1:3,ii),xyz(1:3,i),3) .le. (atomic_vdw_radii(ii)+atomic_vdw_radii(i)+thresh)) then
            nneighbor=nneighbor+1
            neighbor_list(nneighbor)=ii
          endif
        endif
      enddo
      ! Initialize the no points for individual atoms.
      npts = 0
      ! Just a variable name which is appropriate here
      radius = atomic_vdw_radii(i)
      ! We will make circles on the surface similar to latitudes.
      ! First, compute the number of circles to make.
      ncircles = int(PI*radius/espgrid_spacing)+1
      ! Theta is like the azimuthal angle
      start_theta = (PI*radius-(ncircles-1)*espgrid_spacing)/(2*radius)
      ! differnce between the azimuthal angle of consecutive latitudes.
      delta_theta = espgrid_spacing/radius
      ! Loop over all the latitudes.
      do circle = 1, ncircles
        ! Azimuthal angle of this latitude.
        theta = start_theta+delta_theta*(circle-1)
        ! radius of this latitude.
        rcircle = radius*sin(theta)
        ! No of points on this latitude.
        nphi = int(2*PI*rcircle/espgrid_spacing)
        ! angular distance between the points.
        delta_phi = espgrid_spacing/rcircle
        ! Go over all the points
        do j = 1, nphi
          ! Add a new point
          npts = npts + 1
          ! x, y and z coordinates of the point using spherical coordinates.
          xyz_sphere(1,npts) = xyz(1,i) + radius*cos(theta)
          xyz_sphere(2,npts) = xyz(2,i) + radius*sin(theta)*cos((j-1)*delta_phi)
          xyz_sphere(3,npts) = xyz(3,i) + radius*sin(theta)*sin((j-1)*delta_phi)
          ! Go over all the neighbors to check if the newly added point lies inside the scaled
          ! van der waals surface of any of them.
          do k = 1, nneighbor
            if(rootSquare(xyz_sphere(1:3,npts),xyz(1:3,neighbor_list(k)),3) .lt. atomic_vdw_radii(neighbor_list(k)))then
              ! Discarding the point if it is inside the van der waals surface of any of the neighbors
              npts = npts - 1
              ! once the point is discarded we do not need to continue checking rest of the neighbors.
              exit
            end if
          end do
        end do
      end do

      ! Now we are looking for overlapping points.
      ! Special case for the first atom.
      if (npoints.eq.0)then
        ! For the first atom we do not need to check for overlapping points.
        surface_points(1:3,1:npts)=xyz_sphere(1:3,1:npts)
        npoints = npts
        ! Start and end indexes define the range of points belonging to each atom.
        ! This significantly accelerates the checking of overlapping points.
        start_index(i) = 1
        end_index(i) = npoints
      ! Lets consider the atom if it is not the first atom.
      else
        if(int(npoints+npts).gt.int(size(surface_points)/3)) then
          call PrtErr(OUTFILEHANDLE, 'If you are getting segmentation fault, it is due to the no of points on the &
            &van der waals surface exceeds the allocate size of the array.')
          call PrtErr(OUTFILEHANDLE, 'Please adjust the default limit on the size of van der waals surface points &
            &array while computing ESP charges.')
          call quick_exit(OUTFILEHANDLE,1)
        end if
        ! Go over all the newly obtained points.
        do j = 1, npts
          ! Go over all the neighbors to check if there is any overlap with any of their points.
          do k = 1, nneighbor
            ! Only consider the previous atoms for which points on the surface are already generated.
            ! This is perfectly fine as we need to keep only one of the overlapping points.
            if(neighbor_list(k) .lt. i)then
              ! A check to see if we need to consider this point. This check is base on how close this point is to the neighbor.
              if(rootSquare(xyz_sphere(1:3,j), xyz(1:3,neighbor_list(k)),3) .lt. (atomic_vdw_radii(neighbor_list(k))+thresh))then
                ! Consider the distance from all the points of the neighbor to check for proximity
                ! to determine if the points are overlapping.
                do l = start_index(neighbor_list(k)), end_index(neighbor_list(k))
                  if (rootSquare(surface_points(1:3,l), xyz_sphere(1:3,j), 3).lt.thresh)then
                    ! set proximal to true if points are overlapping.
                    proximal = .True.
                    ! once the point is considered overlapping we do not need to continue checking rest of the points.
                    exit
                  end if
                end do
                ! once the point is considered overlapping we do not need to continue checking rest of the neighbors.
                if (proximal)exit
              end if
            end if
          end do
          ! If the point is not overlapping then add it to the list of surface_points.
          if (.not. proximal) then
            npoints = npoints + 1
            surface_points(1:3,npoints) = xyz_sphere(1:3,j)
          else
            proximal = .False.
          end if
        end do
        ! We need to add the range of points for this atom. But, first we need to check if it has any points.
        if(npoints .gt. end_index(i-1))then
          start_index(i) = end_index(i-1) + 1
          end_index(i) = npoints
        end if
      end if
    end do

  end subroutine generate_vdW_surface

end module quick_molsurface_module
